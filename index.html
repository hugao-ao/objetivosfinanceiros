<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Calculadora de Múltiplos Objetivos Avançada</title>
  <link rel="icon" href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    :root {
      --verde-esmeralda: #046c4e;
      --verde-esmeralda-escuro: #034e38;
      --verde-claro: #28a745;
      --verde-medio: #218838;
      --dourado: #d4af37;
      --dourado-claro: #f5e2a9;
      --dourado-escuro: #b38e2e;
      --roxo: #6f42c1;
      --roxo-claro: #9f75e5;
      --roxo-escuro: #4b2882;
      --fundo-claro: #f9f9f9;
      --fundo-container: #ffffff;
      --vermelho-translucido: rgba(255, 0, 0, 0.1);
      --azul-translucido: rgba(0, 0, 255, 0.1);
      --roxo-translucido: rgba(111, 66, 193, 0.1);
      --cinza-claro: #e9ecef;
      --cinza-medio: #ced4da;
      --cinza-escuro: #6c757d;
      --verde-destaque: rgba(4, 108, 78, 0.1);
      --vermelho-destaque: rgba(220, 53, 69, 0.1);
      --sombra-padrao: 0 4px 12px rgba(0,0,0,0.1);
      --borda-arredondada: 8px;
      --espacamento-padrao: 20px;
      --transicao-padrao: all 0.3s ease;
    }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background-color: var(--fundo-claro);
      color: var(--verde-esmeralda-escuro);
      margin: 0;
      padding: var(--espacamento-padrao);
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
      line-height: 1.6;
    }
    h1, h2, h3, h4, h5, h6 {
      color: var(--verde-esmeralda);
      margin-top: 0;
      margin-bottom: var(--espacamento-padrao);
      font-weight: 600;
      line-height: 1.3;
    }
    h1 {
      color: var(--verde-esmeralda-escuro);
      text-align: center;
      font-size: 2.2rem;
      margin-bottom: 1.5rem;
      border-bottom: 3px solid var(--dourado);
      padding-bottom: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    form {
      background-color: var(--fundo-container);
      padding: var(--espacamento-padrao);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
      margin-bottom: var(--espacamento-padrao);
      border: 1px solid var(--cinza-claro);
    }
    .result {
      margin-top: var(--espacamento-padrao);
      padding: var(--espacamento-padrao);
      border: 2px solid var(--dourado);
      background-color: var(--fundo-container);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
    }
    .result h4 {
        color: var(--verde-esmeralda-escuro);
        border-bottom: 1px solid var(--dourado-claro);
        padding-bottom: 10px;
        margin-bottom: 15px;
    }
    .recommendation {
      margin: var(--espacamento-padrao) 0;
      padding: var(--espacamento-padrao);
      border: 2px solid var(--verde-esmeralda);
      background-color: var(--fundo-container);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
    }
    .recommendation h3 {
      color: var(--verde-esmeralda-escuro);
      margin-top: 0;
      border-bottom: 2px solid var(--dourado);
      padding-bottom: 10px;
      font-size: 1.4rem;
    }
    .whatsapp-button {
      display: block;
      width: 100%;
      padding: 15px;
      margin: var(--espacamento-padrao) 0;
      background-color: var(--verde-esmeralda);
      color: white;
      text-align: center;
      font-weight: bold;
      font-size: 1.2rem;
      border: none;
      border-radius: var(--borda-arredondada);
      cursor: pointer;
      text-decoration: none;
      box-shadow: var(--sombra-padrao);
      transition: var(--transicao-padrao);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .whatsapp-button:hover {
      background-color: var(--verde-esmeralda-escuro);
      transform: translateY(-2px);
    }
    .save-scenario-button, .analyze-scenario-button, .new-scenario-button {
      display: block;
      width: 100%;
      padding: 15px;
      margin: var(--espacamento-padrao) 0;
      color: white;
      text-align: center;
      font-weight: bold;
      font-size: 1rem;
      border: none;
      border-radius: var(--borda-arredondada);
      cursor: pointer;
      text-decoration: none;
      box-shadow: var(--sombra-padrao);
      transition: var(--transicao-padrao);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .save-scenario-button { background-color: var(--dourado); }
    .save-scenario-button:hover { background-color: var(--dourado-escuro); transform: translateY(-2px); }
    .analyze-scenario-button { background-color: var(--verde-esmeralda); }
    .analyze-scenario-button:hover { background-color: var(--verde-esmeralda-escuro); transform: translateY(-2px); }
    .new-scenario-button { background-color: var(--dourado); }
    .new-scenario-button:hover { background-color: var(--dourado-escuro); transform: translateY(-2px); }

    label {
      display: block;
      margin-top: 15px;
      margin-bottom: 5px;
      font-weight: 500;
      color: var(--verde-esmeralda-escuro);
    }
    .row {
      display: flex;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      justify-content: space-between;
      gap: 15px;
      margin-bottom: 15px;
    }
    .row > div {
      flex: 1;
      min-width: 150px; /* Prevent fields from becoming too narrow */
    }
    input, select, textarea {
      width: 100%;
      padding: 12px;
      margin-top: 5px;
      box-sizing: border-box;
      border: 1px solid var(--cinza-medio);
      border-radius: var(--borda-arredondada);
      transition: var(--transicao-padrao);
      font-size: 1rem;
    }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--dourado);
      box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
    }
    textarea {
      min-height: 80px; /* Reduced height */
      resize: vertical;
    }
    button {
      margin-top: 20px;
      padding: 14px;
      background-color: var(--verde-esmeralda);
      color: white;
      border: none;
      border-radius: var(--borda-arredondada);
      cursor: pointer;
      width: 100%;
      font-weight: bold;
      font-size: 1rem;
      transition: var(--transicao-padrao);
      letter-spacing: 0.5px;
    }
    button:hover {
      background-color: var(--verde-esmeralda-escuro);
      transform: translateY(-2px);
    }
    .chart-container {
      margin-top: 30px;
      position: relative;
      border: 2px solid var(--dourado-claro);
      border-radius: var(--borda-arredondada);
      padding: 20px;
      background-color: var(--fundo-container);
      box-shadow: var(--sombra-padrao);
    }
    .chart-title {
      text-align: center;
      font-weight: bold;
      margin-bottom: 20px;
      color: var(--verde-esmeralda-escuro);
      font-size: 1.2rem;
      border-bottom: 1px solid var(--dourado);
      padding-bottom: 10px;
    }
    .chart-nav {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 15px;
    }
    .chart-nav button {
      padding: 10px 20px;
      margin-top: 0;
      width: auto;
      font-size: 0.9rem;
      background-color: var(--dourado);
      border-radius: var(--borda-arredondada);
      transition: var(--transicao-padrao);
    }
    .chart-nav button:hover {
      background-color: var(--dourado-escuro);
    }
    .chart-content {
      display: flex;
      overflow: hidden;
      position: relative;
      height: 400px;
      border: 1px solid var(--cinza-claro);
      border-radius: var(--borda-arredondada);
      background-color: var(--fundo-container);
    }
    .chart-slide {
      flex: 0 0 100%;
      transition: transform 0.3s ease;
    }
    .table-slide {
      flex: 0 0 100%;
      overflow-x: auto;
      overflow-y: auto;
      padding: 15px;
      background-color: var(--fundo-container);
      max-height: 400px; /* Limit table height */
    }
    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      min-width: 800px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    .data-table th, .data-table td {
      border: 1px solid var(--cinza-claro);
      padding: 10px;
      text-align: right;
      white-space: nowrap;
    }
    .data-table th {
      background-color: var(--verde-esmeralda);
      color: white;
      font-weight: 600;
      text-align: center;
      text-transform: uppercase;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .data-table tr:nth-child(even) {
      background-color: var(--verde-destaque);
    }
    .data-table tr:hover {
      background-color: var(--dourado-claro);
    }
    .scenarios-container {
      margin: 30px 0;
      padding: 20px;
      border: 2px solid var(--dourado);
      background-color: var(--fundo-container);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
    }
    .scenarios-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 2px solid var(--verde-esmeralda);
      padding-bottom: 10px;
    }
    .scenarios-header h3 {
      color: var(--verde-esmeralda-escuro);
      margin: 0;
      font-size: 1.4rem;
    }
    .scenario-card {
      border: 1px solid var(--cinza-medio);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      background-color: var(--cinza-claro);
      position: relative;
    }
    .scenario-card.active {
      border: 2px solid var(--verde-esmeralda);
      background-color: white;
    }
    .scenario-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .scenario-title {
      font-weight: bold;
      color: var(--verde-esmeralda);
      margin: 0;
    }
    .scenario-actions {
      display: flex;
      gap: 10px;
    }
    .scenario-actions button {
      padding: 5px 10px;
      margin: 0;
      width: auto;
      font-size: 12px;
    }
    .scenario-delete {
      background-color: #dc3545;
    }
    .scenario-delete:hover {
      background-color: #c82333;
    }
    .scenario-select {
      background-color: var(--dourado);
    }
    .scenario-select:hover {
      background-color: var(--dourado-escuro);
    }
    .scenario-content {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .scenario-info {
      flex: 1;
      min-width: 200px;
    }
    .scenario-info p {
      margin: 5px 0;
    }
    .scenario-info strong {
      color: var(--verde-esmeralda);
    }
    .scenario-details {
      margin-top: 10px;
      padding: 10px;
      background-color: var(--fundo-claro);
      border-radius: 5px;
      font-size: 14px;
    }
    .scenario-details ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .scenario-details li {
      margin-bottom: 5px;
    }
    /* Estilos para comparação de cenários */
    .comparison-container {
      margin-top: 30px;
      border: 2px solid var(--roxo);
      border-radius: 8px;
      padding: 15px;
      background-color: white;
    }
    .comparison-header {
      color: var(--roxo);
      margin-top: 0;
      border-bottom: 1px solid var(--dourado-claro);
      padding-bottom: 10px;
      text-align: center;
    }
    .comparison-chart-container {
      height: 400px;
      margin: 20px 0;
    }
    #comparisonTableContainer {
      overflow-x: auto; /* Habilitar rolagem horizontal */
    }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      min-width: 900px; /* Garantir largura mínima para forçar rolagem se necessário */
    }
    .comparison-table th, .comparison-table td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: center;
      white-space: nowrap; /* Evitar quebra de linha nas células */
    }
    .comparison-table th {
      background-color: var(--roxo-translucido);
      color: var(--roxo-escuro);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .comparison-table tr:nth-child(even) {
      background-color: var(--fundo-claro);
    }
    .comparison-table .best-value {
      font-weight: bold;
      color: var(--verde-esmeralda);
      background-color: var(--verde-destaque);
    }
    .comparison-table .worst-value {
      font-weight: bold;
      color: #dc3545;
      background-color: var(--vermelho-destaque);
    }
    .general-analysis {
      margin-top: 30px;
      padding: 20px;
      border: 2px solid var(--roxo);
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .general-analysis h3 {
      color: var(--roxo);
      margin-top: 0;
      border-bottom: 1px solid var(--dourado-claro);
      padding-bottom: 10px;
      text-align: center;
    }

    /* Estilos para a seção de múltiplos objetivos */
    .objectives-section {
      background-color: var(--fundo-container);
      padding: var(--espacamento-padrao);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
      margin-bottom: var(--espacamento-padrao);
      border: 1px solid var(--cinza-claro);
    }
    .objectives-section h3 {
      color: var(--verde-esmeralda);
      margin-top: 0;
      margin-bottom: 15px;
      border-bottom: 2px solid var(--dourado);
      padding-bottom: 10px;
    }
    .objective-input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      align-items: flex-end; /* Align items to bottom for button */
      margin-bottom: 15px;
    }
    .objective-input-group > div {
      flex: 1;
      min-width: 120px;
    }
    .objective-input-group button {
      flex-basis: 100px; /* Fixed width for button */
      margin-top: 0; /* Remove default top margin */
      padding: 12px; /* Match input padding */
      height: 46px; /* Match input height */
      font-size: 0.9rem;
      width: auto;
    }
    #objectivesList {
      margin-top: 15px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--cinza-medio);
      border-radius: var(--borda-arredondada);
      padding: 10px;
    }
    .objective-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid var(--cinza-claro);
      background-color: var(--fundo-claro);
      border-radius: 4px;
      margin-bottom: 5px;
    }
    .objective-item:last-child {
      border-bottom: none;
    }
    .objective-item span {
      flex-grow: 1;
      margin-right: 10px;
      font-size: 0.9rem;
    }
    .objective-item button {
      padding: 4px 8px;
      margin: 0;
      width: auto;
      font-size: 0.8rem;
      background-color: #dc3545;
      line-height: 1;
    }
    .objective-item button:hover {
      background-color: #c82333;
    }

  </style>
</head>
<body>
  <h1>Calculadora de Múltiplos Objetivos Avançada</h1>

  <!-- Seção para Adicionar/Gerenciar Objetivos -->
  <div class="objectives-section">
    <h3>Seus Objetivos</h3>
    <div class="objective-input-group">
      <div>
        <label for="newObjectiveDescription">Descrição</label>
        <input type="text" id="newObjectiveDescription" placeholder="Ex: Viagem Europa">
      </div>
      <div>
        <label for="newObjectiveValue">Valor (R$)</label>
        <input type="text" id="newObjectiveValue" placeholder="R$ 15.000,00" oninput="formatCurrency(this)">
      </div>
      <div>
        <label for="newObjectivePeriod">Prazo (meses)</label>
        <input type="number" id="newObjectivePeriod" placeholder="24">
      </div>
      <button type="button" onclick="addObjective()">Adicionar</button>
    </div>
    <div id="objectivesListContainer">
      <label>Objetivos Adicionados:</label>
      <div id="objectivesList">
        <!-- Objetivos serão listados aqui -->
        <p style="text-align: center; color: var(--cinza-escuro);">Nenhum objetivo adicionado ainda.</p>
      </div>
    </div>
  </div>

  <!-- Formulário Principal com Parâmetros Financeiros Comuns -->
  <form id="savingsForm" onsubmit="event.preventDefault(); calculateSavings();">
    <h3>Parâmetros Financeiros</h3>

    <label for="currentSavings">Valor já Guardado (R$):</label>
    <input type="text" id="currentSavings" required oninput="formatCurrency(this)">

    <label for="currentContribution">Quanto você poupa atualmente por mês (R$):</label>
    <input type="text" id="currentContribution" required oninput="formatCurrency(this)">

    <div class="row">
      <div>
        <label for="rate">Taxa de Juros (%):</label>
        <input type="text" id="rate" required oninput="formatPercentage(this)">
      </div>
      <div>
        <label for="rateType">Tipo de Taxa:</label>
        <select id="rateType">
          <option value="annual">Anual</option>
          <option value="monthly">Mensal</option>
        </select>
      </div>
    </div>

    <label>Você sabe a alíquota de imposto sobre o rendimento?</label>
    <div class="row">
      <div>
        <select id="knowsTax" onchange="toggleTaxInput('tax', '15,00 %')">
          <option value="no">Não</option>
          <option value="yes">Sim</option>
        </select>
      </div>
      <div>
        <input type="text" id="tax" placeholder="15,00 %" value="15,00 %" oninput="formatPercentage(this)" disabled>
      </div>
    </div>

    <label>Você sabe a taxa de inflação anual?</label>
    <div class="row">
      <div>
        <select id="knowsInflation" onchange="toggleTaxInput('inflation', '5,00 %')">
          <option value="no">Não</option>
          <option value="yes">Sim</option>
        </select>
      </div>
      <div>
        <input type="text" id="inflation" placeholder="5,00 %" value="5,00 %" oninput="formatPercentage(this)" disabled>
      </div>
    </div>

    <button type="submit">Calcular Cenário</button>
  </form>

  <div id="result" class="result" style="display: none;"></div>

  <div id="recommendation" class="recommendation" style="display: none;">
    <h3>Análise Automatizada</h3>
    <div id="recommendationText"></div>
  </div>

  <!-- Botões para salvar cenário, analisar cenários e simular outro cenário -->
  <div class="row" style="margin-top: 20px;">
    <div style="flex: 1; margin-right: 10px;">
      <button id="saveScenarioButton" class="save-scenario-button" type="button" onclick="addCurrentScenario()" style="display: none;">
        SALVAR CENÁRIO
      </button>
    </div>
    <div style="flex: 1; margin-left: 10px; margin-right: 10px;">
      <button id="analyzeScenarioButton" class="analyze-scenario-button" type="button" onclick="analyzeScenarios()" style="display: none;">
        ANALISAR CENÁRIOS
      </button>
    </div>
    <div style="flex: 1; margin-left: 10px;">
      <button id="newScenarioButton" class="new-scenario-button" type="button" onclick="prepareNewScenario()" style="display: none;">
        LIMPAR PARA NOVO CÁLCULO
      </button>
    </div>
  </div>

  <!-- Botão WhatsApp para análise personalizada - sempre visível após cálculo -->
  <a id="whatsappButton" href="#" class="whatsapp-button" onclick="openWhatsAppChat()" style="display: none;">
    AVANÇAR PARA ANÁLISE PERSONALIZADA
  </a>

  <!-- Container Único para Gráfico/Tabela de Projeção -->
  <div id="projectionChartContainer" class="chart-container" style="display: none;">
    <div class="chart-title">Evolução da Projeção Financeira</div>
    <div class="chart-nav">
      <button type="button" onclick="showChartSlide('Projection', 'chart')">Gráfico</button>
      <button type="button" onclick="showChartSlide('Projection', 'table')">Memória de Cálculo</button>
    </div>
    <div class="chart-content">
      <div id="chartProjectionSlide" class="chart-slide">
        <canvas id="chartProjection"></canvas>
      </div>
      <div id="tableProjectionSlide" class="table-slide" style="display: none;">
        <table id="tableProjection" class="data-table">
          <thead>
            <tr>
              <th scope="col">Mês</th>
              <th scope="col">Total Investido</th>
              <th scope="col">Juros</th>
              <th scope="col">Total Juros</th>
              <th scope="col">Total Acumulado</th>
              <th scope="col">Imposto</th>
              <th scope="col">Valor Líquido</th>
              <!-- Coluna de Objetivo Corrigido pode ser adicionada se necessário -->
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Container para Análise 1: Valor Inicial Necessário -->
  <div id="analysisInitialValueContainer" class="chart-container" style="display: none; border-color: var(--verde-claro);">
    <div class="chart-title">Análise: Valor Inicial Necessário (sem aportes)</div>
    <p id="resultInitialValue" style="text-align: center; font-weight: bold; margin-bottom: 15px;"></p>
    <div class="chart-nav">
      <button type="button" onclick="showChartSlide('InitialValue', 'chart')">Gráfico</button>
      <button type="button" onclick="showChartSlide('InitialValue', 'table')">Memória de Cálculo</button>
    </div>
    <div class="chart-content">
      <div id="chartInitialValueSlide" class="chart-slide">
        <canvas id="chartInitialValue"></canvas>
      </div>
      <div id="tableInitialValueSlide" class="table-slide" style="display: none;">
        <table id="tableInitialValue" class="data-table">
          <thead>
            <tr>
              <th scope="col">Mês</th><th scope="col">Total Investido</th><th scope="col">Juros</th><th scope="col">Total Juros</th><th scope="col">Total Acumulado</th><th scope="col">Imposto</th><th scope="col">Valor Líquido</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Container para Análise 2: Aporte Mensal Ideal -->
  <div id="analysisIdealContributionContainer" class="chart-container" style="display: none; border-color: var(--verde-medio);">
    <div class="chart-title">Análise: Aporte Mensal Ideal</div>
    <p id="resultIdealContribution" style="text-align: center; font-weight: bold; margin-bottom: 15px;"></p>
    <div class="chart-nav">
      <button type="button" onclick="showChartSlide('IdealContribution', 'chart')">Gráfico</button>
      <button type="button" onclick="showChartSlide('IdealContribution', 'table')">Memória de Cálculo</button>
    </div>
    <div class="chart-content">
      <div id="chartIdealContributionSlide" class="chart-slide">
        <canvas id="chartIdealContribution"></canvas>
      </div>
      <div id="tableIdealContributionSlide" class="table-slide" style="display: none;">
        <table id="tableIdealContribution" class="data-table">
          <thead>
             <tr>
              <th scope="col">Mês</th><th scope="col">Total Investido</th><th scope="col">Juros</th><th scope="col">Total Juros</th><th scope="col">Total Acumulado</th><th scope="col">Imposto</th><th scope="col">Valor Líquido</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Container para Análise 3: Tempo Necessário -->
  <div id="analysisRequiredTimeContainer" class="chart-container" style="display: none; border-color: var(--roxo-claro);">
    <div class="chart-title">Análise: Tempo Necessário</div>
    <p id="resultRequiredTime" style="text-align: center; font-weight: bold; margin-bottom: 15px;"></p>
    <div class="chart-nav">
      <button type="button" onclick="showChartSlide('RequiredTime', 'chart')">Gráfico</button>
      <button type="button" onclick="showChartSlide('RequiredTime', 'table')">Memória de Cálculo</button>
    </div>
    <div class="chart-content">
      <div id="chartRequiredTimeSlide" class="chart-slide">
        <canvas id="chartRequiredTime"></canvas>
      </div>
      <div id="tableRequiredTimeSlide" class="table-slide" style="display: none;">
        <table id="tableRequiredTime" class="data-table">
          <thead>
             <tr>
              <th scope="col">Mês</th><th scope="col">Total Investido</th><th scope="col">Juros</th><th scope="col">Total Juros</th><th scope="col">Total Acumulado</th><th scope="col">Imposto</th><th scope="col">Valor Líquido</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Container para Análise 4: Rentabilidade Anual Ideal -->
  <div id="analysisIdealRateContainer" class="chart-container" style="display: none; border-color: var(--dourado-escuro);">
    <div class="chart-title">Análise: Rentabilidade Anual Ideal</div>
    <p id="resultIdealRate" style="text-align: center; font-weight: bold; margin-bottom: 15px;"></p>
    <div class="chart-nav">
      <button type="button" onclick="showChartSlide('IdealRate', 'chart')">Gráfico</button>
      <button type="button" onclick="showChartSlide('IdealRate', 'table')">Memória de Cálculo</button>
    </div>
    <div class="chart-content">
      <div id="chartIdealRateSlide" class="chart-slide">
        <canvas id="chartIdealRate"></canvas>
      </div>
      <div id="tableIdealRateSlide" class="table-slide" style="display: none;">
        <table id="tableIdealRate" class="data-table">
          <thead>
             <tr>
              <th scope="col">Mês</th><th scope="col">Total Investido</th><th scope="col">Juros</th><th scope="col">Total Juros</th><th scope="col">Total Acumulado</th><th scope="col">Imposto</th><th scope="col">Valor Líquido</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Container para Cenários Salvos -->
  <div id="scenariosContainer" class="scenarios-container" style="display: none;">
    <div class="scenarios-header">
      <h3>Cenários Salvos</h3>
    </div>
    <div id="scenariosList"></div>
  </div>

  <!-- Container para Comparação de Cenários -->
  <div id="comparisonContainer" class="comparison-container" style="display: none;">
    <h3 class="comparison-header">Comparação de Cenários</h3>
    <div id="comparisonChartContainer" class="comparison-chart-container">
      <canvas id="comparisonChart"></canvas>
    </div>
    <div id="comparisonTableContainer">
      <table id="comparisonTable" class="comparison-table">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Container para Análise Geral -->
   <div id="generalAnalysis" class="general-analysis" style="display: none;">
    <h3>Análise Geral dos Cenários</h3>
    <div id="generalAnalysisText"></div>
  </div>


  <script>
    // --- Variáveis Globais ---
    let objectives = []; // Array para armazenar os múltiplos objetivos
    let scenarios = []; // Array para armazenar os cenários salvos
    let scenarioCounter = 1; // Contador para nomeação automática de cenários
    let currentCalculationData = null; // Armazena os dados do cálculo atual
    let projectionChart = null; // Referência para o gráfico de projeção
    let comparisonChart = null; // Referência para o gráfico de comparação
    // Referências para os gráficos das análises adicionais
    let initialValueChart = null;
    let idealContributionChart = null;
    let requiredTimeChart = null;
    let idealRateChart = null;

    // --- Funções de Formatação e Utilitários ---
    function formatCurrency(input) {
      let value = input.value.replace(/\D/g, "");
      value = (parseFloat(value) / 100).toFixed(2);
      if (isNaN(value) || value === "NaN") value = "0.00";
      input.value = "R$ " + parseFloat(value).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    function formatPercentage(input) {
      let value = input.value.replace(/[^\d,]/g, "").replace(",", "."); // Permite vírgula como decimal
      value = parseFloat(value);
      if (isNaN(value)) value = 0;
      // Formata com duas casas decimais e vírgula
      input.value = value.toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2}) + " %";
    }

    function toggleTaxInput(id, defaultValue) {
      const selectElementId = id === "tax" ? "knowsTax" : "knowsInflation";
      const select = document.getElementById(selectElementId);
      const input = document.getElementById(id);
      if (select.value === "yes") {
        input.disabled = false;
        input.value = ""; // Limpa o valor se o usuário sabe
        input.placeholder = defaultValue; // Mantém o placeholder como guia
      } else {
        input.disabled = true;
        input.value = defaultValue; // Define o valor padrão se o usuário não sabe
      }
    }

    function parseCurrency(value) {
      if (typeof value !== 'string') return 0;
      return parseFloat(value.replace(/R\$\s?/g, "").replace(/\./g, "").replace(",", ".")) || 0;
    }

    function parsePercentage(value) {
       if (typeof value !== 'string') return 0;
      return parseFloat(value.replace(/%\s?/g, "").replace(",", ".")) / 100 || 0;
    }

    function formatMoney(value) {
        if (typeof value !== 'number' || isNaN(value) || !isFinite(value)) {
            return "N/A"; // Retorna N/A para valores inválidos ou infinitos
        }
        return "R$ " + value.toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    function formatMonths(months) {
        if (typeof months !== 'number' || isNaN(months) || !isFinite(months)) {
            return "N/A";
        }
        if (months === Infinity) return "Inatingível";
        const years = Math.floor(months / 12);
        const remainingMonths = months % 12;
        let result = "";
        if (years > 0) {
            result += `${years} ano${years > 1 ? 's' : ''}`;
        }
        if (remainingMonths > 0) {
            if (years > 0) result += " e ";
            result += `${remainingMonths} ${remainingMonths > 1 ? 'meses' : 'mês'}`;
        }
        if (result === "") result = "0 meses"; // Caso months seja 0
        return result;
    }

    function formatRate(rate) {
         if (typeof rate !== 'number' || isNaN(rate) || !isFinite(rate)) {
            return "N/A";
        }
        if (rate === Infinity) return "Inatingível";
        return (rate * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2}) + "% a.a.";
    }

    function showChartSlide(containerId, slideType) {
      const chartSlide = document.getElementById(`chart${containerId}Slide`);
      const tableSlide = document.getElementById(`table${containerId}Slide`);

      if (slideType === "chart") {
        chartSlide.style.display = "block";
        tableSlide.style.display = "none";
      } else {
        chartSlide.style.display = "none";
        tableSlide.style.display = "block";
      }
    }

    // --- Funções de Gerenciamento de Objetivos ---
    function addObjective() {
      const descriptionInput = document.getElementById("newObjectiveDescription");
      const valueInput = document.getElementById("newObjectiveValue");
      const periodInput = document.getElementById("newObjectivePeriod");

      const description = descriptionInput.value.trim();
      const value = parseCurrency(valueInput.value);
      const period = parseInt(periodInput.value);

      if (!description) {
        alert("Por favor, insira uma descrição para o objetivo.");
        return;
      }
      if (isNaN(value) || value <= 0) {
        alert("Por favor, insira um valor válido para o objetivo.");
        return;
      }
      if (isNaN(period) || period <= 0) {
        alert("Por favor, insira um prazo válido (em meses) para o objetivo.");
        return;
      }

      objectives.push({ description, value, period });
      displayObjectives();

      // Limpar campos
      descriptionInput.value = "";
      valueInput.value = "";
      periodInput.value = "";
    }

    function deleteObjective(index) {
      objectives.splice(index, 1);
      displayObjectives();
    }

    function displayObjectives() {
      const listDiv = document.getElementById("objectivesList");
      listDiv.innerHTML = ""; // Limpar lista

      if (objectives.length === 0) {
        listDiv.innerHTML = '<p style="text-align: center; color: var(--cinza-escuro);">Nenhum objetivo adicionado ainda.</p>';
        return;
      }

      objectives.forEach((obj, index) => {
        const item = document.createElement("div");
        item.className = "objective-item";
        item.innerHTML = `
          <span>${obj.description} - ${formatMoney(obj.value)} em ${obj.period} meses</span>
          <button type="button" onclick="deleteObjective(${index})">Excluir</button>
        `;
        listDiv.appendChild(item);
      });
    }

    // --- Funções de Cálculo Principal e Auxiliares ---
    function calculateCompoundInterest(initialValue, monthlyContribution, monthlyRate, maxMonths, tax, annualInflation) {
      let totalValue = initialValue;
      let totalInvested = initialValue;
      let totalJuros = 0;
      let valoresMensais = [];
      const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

      // Registrar valores iniciais (mês 0)
      valoresMensais.push({
        month: 0,
        juros: 0,
        totalInvestido: totalInvested,
        totalJuros: 0,
        imposto: 0,
        valorLiquido: totalValue,
        totalAcumulado: totalValue
      });

      for (let month = 1; month <= maxMonths; month++) {
        const jurosDoMes = totalValue * monthlyRate;
        totalJuros += jurosDoMes;
        totalValue += jurosDoMes + monthlyContribution;
        totalInvested += monthlyContribution;

        // Imposto calculado sobre o ganho de capital (Juros Totais)
        const impostoTotal = totalJuros * tax;
        const valorLiquido = totalValue - impostoTotal;

        valoresMensais.push({
          month: month,
          juros: jurosDoMes,
          totalInvestido: totalInvested,
          totalJuros: totalJuros,
          imposto: impostoTotal,
          valorLiquido: valorLiquido,
          totalAcumulado: totalValue
        });
      }

      return {
        finalValue: totalValue,
        totalInvested: totalInvested,
        totalJuros: totalJuros,
        totalImposto: totalJuros * tax,
        valoresMensais: valoresMensais
      };
    }

    // Função auxiliar para verificar se todos os objetivos são atingidos em uma simulação
    function checkAllObjectivesMet(objectives, valoresMensais, annualInflation) {
        if (!valoresMensais || valoresMensais.length === 0) return false;
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

        for (const obj of objectives) {
            const targetMonth = obj.period;
            if (targetMonth >= valoresMensais.length) {
                // Simulação não cobriu o prazo deste objetivo
                // console.log(`Simulação curta para ${obj.description} (Prazo: ${targetMonth}, Simulado: ${valoresMensais.length -1})`);
                return false;
            }
            const inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, targetMonth);
            const netValueAtTargetMonth = valoresMensais[targetMonth].valorLiquido;

            // console.log(`Obj: ${obj.description}, Mês: ${targetMonth}, Líquido: ${netValueAtTargetMonth}, Obj Corrigido: ${inflatedObjectiveValue}`);
            if (netValueAtTargetMonth < inflatedObjectiveValue) {
                // Este objetivo não foi atingido
                return false;
            }
        }
        // Se chegou aqui, todos os objetivos foram atingidos
        return true;
    }

    // --- Funções de Cálculo Adicionais --- //

    // 1. Calcular Valor Inicial Necessário (sem aportes) - Retorna { value: number | Infinity, simulation: object | null }
    function calculateRequiredInitialValue(objectives, monthlyRate, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        let low = 0;
        const maxPeriod = Math.max(...objectives.map(o => o.period), 0);
        if (maxPeriod <= 0) return { value: 0, simulation: null };
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;
        let high = objectives.reduce((sum, obj) => sum + obj.value * Math.pow(1 + monthlyInflation, obj.period), 0) * 1.5;

        let requiredInitialValue = Infinity;
        let finalSimulation = null;
        const maxIterations = 100;
        let iterations = 0;

        // Caso especial: taxa zero ou negativa
        if (monthlyRate <= 0) {
            let maxRequired = 0;
            for (const obj of objectives) {
                 const inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, obj.period);
                 maxRequired = Math.max(maxRequired, inflatedObjectiveValue);
            }
            const simulation = calculateCompoundInterest(maxRequired, 0, monthlyRate, maxPeriod, tax, annualInflation);
             if (checkAllObjectivesMet(objectives, simulation.valoresMensais, annualInflation)) {
                 return { value: maxRequired, simulation: simulation };
             } else {
                 return { value: Infinity, simulation: null };
             }
        }

        while (iterations < maxIterations && (high - low) > 0.01) {
            const mid = low + (high - low) / 2;
            if (mid === low || mid === high) break;

            const currentSim = calculateCompoundInterest(mid, 0, monthlyRate, maxPeriod, tax, annualInflation);

            if (checkAllObjectivesMet(objectives, currentSim.valoresMensais, annualInflation)) {
                requiredInitialValue = mid;
                finalSimulation = currentSim; // Guarda a simulação que funcionou
                high = mid;
            } else {
                low = mid;
            }
            iterations++;
        }

        if (requiredInitialValue === Infinity) {
            // Se não encontrou, retorna Infinity e nenhuma simulação
             return { value: Infinity, simulation: null };
        } else {
            // Retorna o valor encontrado e a simulação correspondente
            const finalValue = requiredInitialValue < 0.01 ? 0 : requiredInitialValue;
            // Recalcular a simulação final com o valor exato encontrado (se necessário, mas já temos finalSimulation)
            // Se o valor final for 0, a simulação deve ser recalculada
            if (finalValue === 0 && requiredInitialValue >= 0.01) {
                 finalSimulation = calculateCompoundInterest(0, 0, monthlyRate, maxPeriod, tax, annualInflation);
            }
            return { value: finalValue, simulation: finalSimulation };
        }
    }

    // 2. Calcular Aporte Mensal Ideal Constante - Retorna { value: number | Infinity, simulation: object | null }
    function calculateIdealMonthlyContribution(objectives, initialSavings, monthlyRate, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        let low = 0;
        const maxPeriod = Math.max(...objectives.map(o => o.period), 0);
        if (maxPeriod <= 0) return { value: 0, simulation: null };
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;
        let totalDeficit = 0;
        objectives.forEach(obj => {
            const inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, obj.period);
            const fvInitialSavings = initialSavings * Math.pow(1 + monthlyRate, obj.period);
            totalDeficit += Math.max(0, inflatedObjectiveValue - fvInitialSavings);
        });
        let high = (totalDeficit / maxPeriod) * 2 + 100;
        if (high < 100) high = 100;

        let idealContribution = Infinity;
        let finalSimulation = null;
        const maxIterations = 100;
        let iterations = 0;

        // Caso base: verificar se já atinge com 0 aporte
        const initialSimulation = calculateCompoundInterest(initialSavings, 0, monthlyRate, maxPeriod, tax, annualInflation);
        if (checkAllObjectivesMet(objectives, initialSimulation.valoresMensais, annualInflation)) {
            return { value: 0, simulation: initialSimulation }; // Nenhum aporte necessário
        }

        while (iterations < maxIterations && (high - low) > 0.01) {
            const mid = low + (high - low) / 2;
             if (mid === low || mid === high) break;

            const currentSim = calculateCompoundInterest(initialSavings, mid, monthlyRate, maxPeriod, tax, annualInflation);

            if (checkAllObjectivesMet(objectives, currentSim.valoresMensais, annualInflation)) {
                idealContribution = mid;
                finalSimulation = currentSim; // Guarda a simulação que funcionou
                high = mid;
            } else {
                low = mid;
            }
            iterations++;
        }

        if (idealContribution === Infinity) {
            // Verificar o limite superior inicial
            const highSim = calculateCompoundInterest(initialSavings, high, monthlyRate, maxPeriod, tax, annualInflation);
            if (checkAllObjectivesMet(objectives, highSim.valoresMensais, annualInflation)) {
                 // Se o high inicial funcionou, mas a busca não convergiu para ele
                 return { value: high, simulation: highSim };
            } else {
                console.warn("Não foi possível encontrar um aporte mensal suficiente dentro dos limites/iterações.");
                return { value: Infinity, simulation: null };
            }
        } else {
             const finalValue = idealContribution < 0.01 ? 0 : idealContribution;
             // Se o valor final for 0, a simulação deve ser a inicial
             if (finalValue === 0 && idealContribution >= 0.01) {
                 finalSimulation = initialSimulation;
             }
             return { value: finalValue, simulation: finalSimulation };
        }
    }

    // 3. Calcular Tempo Necessário para Atingir Objetivos - Retorna { value: number | Infinity, simulation: object | null }
    function calculateRequiredTime(objectives, initialSavings, monthlyContribution, monthlyRate, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        let totalValue = initialSavings;
        let totalInvested = initialSavings;
        let totalJuros = 0;
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;
        const maxSimulationMonths = 1200; // Limite máximo de simulação (100 anos)
        let month = 0;
        let valoresMensaisSimulacao = []; // Para guardar a simulação completa

        let objectivesMetStatus = objectives.map(obj => ({ ...obj, met: false, monthMet: -1 }));
        let allObjectivesMet = false;
        let requiredMonths = Infinity; // Começa com infinito

        // Adicionar estado inicial à simulação
        valoresMensaisSimulacao.push({
            month: 0, juros: 0, totalInvestido: initialSavings, totalJuros: 0,
            imposto: 0, valorLiquido: initialSavings, totalAcumulado: initialSavings
        });

        // Verificar se já foram atingidos no mês 0
        let numMetAtStart = 0;
        objectivesMetStatus.forEach(objStatus => {
            const inflatedObjectiveValue = objStatus.value;
            const netValueAtTargetMonth = initialSavings;
            if (objStatus.period === 0 && netValueAtTargetMonth >= inflatedObjectiveValue) {
                 objStatus.met = true;
                 objStatus.monthMet = 0;
                 numMetAtStart++;
            }
        });
        if (numMetAtStart === objectives.length) {
             // Simulação contém apenas o mês 0
             return { value: 0, simulation: { valoresMensais: valoresMensaisSimulacao } };
        }

        while (month < maxSimulationMonths) {
            month++;

            const jurosDoMes = totalValue * monthlyRate;
            totalJuros += jurosDoMes;
            totalValue += jurosDoMes + monthlyContribution;
            totalInvested += monthlyContribution;

            const impostoTotal = totalJuros * tax;
            const valorLiquido = totalValue - impostoTotal;

            // Adicionar dados do mês atual à simulação
            valoresMensaisSimulacao.push({
                month: month, juros: jurosDoMes, totalInvestido: totalInvested, totalJuros: totalJuros,
                imposto: impostoTotal, valorLiquido: valorLiquido, totalAcumulado: totalValue
            });

            let objectivesMetCount = 0;
            objectivesMetStatus.forEach(objStatus => {
                if (!objStatus.met) {
                    const inflatedObjectiveValue = objStatus.value * Math.pow(1 + monthlyInflation, month);
                    if (valorLiquido >= inflatedObjectiveValue) {
                        objStatus.met = true;
                        objStatus.monthMet = month;
                    }
                }
                if (objStatus.met) {
                    objectivesMetCount++;
                }
            });

            if (objectivesMetCount === objectives.length) {
                allObjectivesMet = true;
                requiredMonths = Math.max(...objectivesMetStatus.map(o => o.monthMet));
                break;
            }
        }

        if (requiredMonths === Infinity) {
            // Se não atingiu, retorna Infinity e a simulação até o limite máximo
            return { value: Infinity, simulation: { valoresMensais: valoresMensaisSimulacao } };
        } else {
            // Se atingiu, retorna os meses e a simulação até esse ponto
            // (A simulação já foi construída até o mês 'requiredMonths')
            return { value: requiredMonths, simulation: { valoresMensais: valoresMensaisSimulacao.slice(0, requiredMonths + 1) } };
        }
    }

    // 4. Calcular Rentabilidade Anual Ideal Constante - Retorna { value: number | Infinity, simulation: object | null }
    function calculateIdealAnnualRate(objectives, initialSavings, monthlyContribution, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        let lowMonthlyRate = -0.05; // Permitir taxas negativas pequenas
        let highMonthlyRate = 1.0; // 100% ao mês
        let idealMonthlyRate = Infinity; // Começa com infinito
        let finalSimulation = null;
        const maxIterations = 100;
        let iterations = 0;

        const maxPeriod = Math.max(...objectives.map(o => o.period), 0);
        if (maxPeriod <= 0) return { value: 0, simulation: null }; // Sem prazo válido

        // Caso base: verificar se já atinge com taxa mínima (lowMonthlyRate)
        const lowRateSimulation = calculateCompoundInterest(initialSavings, monthlyContribution, lowMonthlyRate, maxPeriod, tax, annualInflation);
        if (checkAllObjectivesMet(objectives, lowRateSimulation.valoresMensais, annualInflation)) {
             const lowAnnualRate = Math.pow(1 + lowMonthlyRate, 12) - 1;
             // Retorna 0 se a taxa mínima for negativa mas funcionar
             return { value: Math.max(0, lowAnnualRate), simulation: lowRateSimulation };
        }

        while (iterations < maxIterations && (highMonthlyRate - lowMonthlyRate) > 1e-7) {
            const midMonthlyRate = lowMonthlyRate + (highMonthlyRate - lowMonthlyRate) / 2;
            if (midMonthlyRate === lowMonthlyRate || midMonthlyRate === highMonthlyRate) break;

            const currentSim = calculateCompoundInterest(initialSavings, monthlyContribution, midMonthlyRate, maxPeriod, tax, annualInflation);

            if (checkAllObjectivesMet(objectives, currentSim.valoresMensais, annualInflation)) {
                idealMonthlyRate = midMonthlyRate;
                finalSimulation = currentSim; // Guarda a simulação que funcionou
                highMonthlyRate = midMonthlyRate;
            } else {
                lowMonthlyRate = midMonthlyRate;
            }
            iterations++;
        }

        if (idealMonthlyRate !== Infinity) {
            const idealAnnualRate = Math.pow(1 + idealMonthlyRate, 12) - 1;
            const finalValue = idealAnnualRate < 1e-6 ? 0 : idealAnnualRate;
            // Se a taxa final for 0, a simulação correta é a de taxa 0 (que pode não ter sido a 'lowRateSimulation' inicial)
            if (finalValue === 0 && idealAnnualRate >= 1e-6) {
                 finalSimulation = calculateCompoundInterest(initialSavings, monthlyContribution, 0, maxPeriod, tax, annualInflation);
            }
            return { value: finalValue, simulation: finalSimulation };
        } else {
             // Verificar o limite superior
             const highRateSimulation = calculateCompoundInterest(initialSavings, monthlyContribution, highMonthlyRate, maxPeriod, tax, annualInflation);
             if (checkAllObjectivesMet(objectives, highRateSimulation.valoresMensais, annualInflation)) {
                 console.warn("Taxa ideal pode ser muito alta, retornando limite superior.");
                 return { value: Math.pow(1 + highMonthlyRate, 12) - 1, simulation: highRateSimulation };
             } else {
                 console.warn("Não foi possível encontrar uma taxa de rentabilidade suficiente dentro dos limites/iterações.");
                 return { value: Infinity, simulation: null }; // Indica impossibilidade
             }
        }
    }

    // --- Função Principal de Cálculo (Modificada) ---
    function calculateSavings() {
      // Validar se há objetivos
      if (objectives.length === 0) {
        alert("Por favor, adicione pelo menos um objetivo antes de calcular.");
        return;
      }

      // --- Obter Entradas --- //
      const currentSavings = parseCurrency(document.getElementById("currentSavings").value);
      const currentContribution = parseCurrency(document.getElementById("currentContribution").value);
      const rateInput = parsePercentage(document.getElementById("rate").value);
      const rateType = document.getElementById("rateType").value;
      const tax = parsePercentage(document.getElementById("tax").value);
      const annualInflation = parsePercentage(document.getElementById("inflation").value);

      // Validar entradas numéricas
      if (isNaN(currentSavings) || isNaN(currentContribution) || isNaN(rateInput) || isNaN(tax) || isNaN(annualInflation)) {
        alert("Por favor, verifique se todos os valores numéricos (valores, taxas) estão preenchidos corretamente.");
        return;
      }

      // Calcular taxa mensal
      const monthlyRate = rateType === "annual" ? Math.pow(1 + rateInput, 1/12) - 1 : rateInput;

      // Determinar período máximo da simulação (maior prazo entre os objetivos)
      const maxPeriod = Math.max(...objectives.map(o => o.period), 0);
      if (maxPeriod <= 0) {
        alert("Prazo inválido. Verifique os prazos dos objetivos.");
        return;
      }

      // --- Calcular Projeção Principal ---
      const projection = calculateCompoundInterest(currentSavings, currentContribution, monthlyRate, maxPeriod, tax, annualInflation);
      const valoresMensais = projection.valoresMensais;

      // --- Calcular Análises Adicionais (agora retornam { value, simulation }) --- //
      console.time("Additional Calculations");
      const analysisInitial = calculateRequiredInitialValue(objectives, monthlyRate, tax, annualInflation);
      const analysisContribution = calculateIdealMonthlyContribution(objectives, currentSavings, monthlyRate, tax, annualInflation);
      const analysisTime = calculateRequiredTime(objectives, currentSavings, currentContribution, monthlyRate, tax, annualInflation);
      const analysisRate = calculateIdealAnnualRate(objectives, currentSavings, currentContribution, tax, annualInflation);
      console.timeEnd("Additional Calculations");

      // --- Exibir Resultados --- //
      const resultDiv = document.getElementById("result");
      let resultHTML = "<h4>Resultados da Simulação Atual:</h4>";
      let allGoalsMet = true;
      let recommendationDetails = [];

      // Status dos objetivos na simulação principal
      objectives.forEach(obj => {
        const targetMonth = obj.period;
        let objectiveMet = false;
        let monthMet = -1;
        let finalNetValueForObjective = 0;
        let inflatedObjectiveValue = 0;
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

        if (targetMonth < valoresMensais.length) {
          inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, targetMonth);
          finalNetValueForObjective = valoresMensais[targetMonth].valorLiquido;

          if (finalNetValueForObjective >= inflatedObjectiveValue) {
            objectiveMet = true;
            // Encontrar o mês exato em que foi atingido
            for(let m = 1; m <= targetMonth; m++) {
                const currentInflatedValue = obj.value * Math.pow(1 + monthlyInflation, m);
                if (valoresMensais[m].valorLiquido >= currentInflatedValue) {
                    monthMet = m;
                    break;
                }
            }
            if (monthMet === -1) monthMet = targetMonth; // Se atingiu exatamente no final
          } else {
            allGoalsMet = false;
          }

          resultHTML += `<p><strong>${obj.description}:</strong> `;
          if (objectiveMet) {
            resultHTML += `<span style="color: var(--verde-esmeralda);">Atingido!</span> (Valor líquido no mês ${targetMonth}: ${formatMoney(finalNetValueForObjective)} vs Objetivo corrigido: ${formatMoney(inflatedObjectiveValue)}). Atingido no mês ${monthMet}.</p>`;
          } else {
            resultHTML += `<span style="color: #dc3545;">Não Atingido.</span> (Valor líquido no mês ${targetMonth}: ${formatMoney(finalNetValueForObjective)} vs Objetivo corrigido: ${formatMoney(inflatedObjectiveValue)}). Faltam ${formatMoney(inflatedObjectiveValue - finalNetValueForObjective)}.</p>`;
          }
          recommendationDetails.push({ description: obj.description, met: objectiveMet, period: targetMonth, netValue: finalNetValueForObjective, targetValue: inflatedObjectiveValue });
        } else {
           resultHTML += `<p><strong>${obj.description}:</strong> Erro - Prazo do objetivo (${targetMonth} meses) excede a simulação.</p>`;
           allGoalsMet = false;
           recommendationDetails.push({ description: obj.description, met: false, period: targetMonth, netValue: 0, targetValue: obj.value });
        }
      });

      resultHTML += `<p><strong>Projeção Final (${maxPeriod} meses):</strong> Valor Líquido ${formatMoney(valoresMensais[maxPeriod].valorLiquido)} (Total Investido: ${formatMoney(valoresMensais[maxPeriod].totalInvestido)}, Juros Brutos: ${formatMoney(valoresMensais[maxPeriod].totalJuros)}, Imposto Estimado: ${formatMoney(valoresMensais[maxPeriod].imposto)})</p>`;

      // Limpar resultados das análises adicionais antes de exibir
      clearAnalysisResults();

      // Adicionar resultados das análises adicionais ao DIV principal (opcional, pois terão seções próprias)
      resultHTML += "<hr><h4>Análises Adicionais (Resumo):</h4>";
      resultHTML += `<p><strong>1. Valor Inicial Necessário (sem aportes):</strong> ${formatMoney(analysisInitial.value)}</p>`;
      resultHTML += `<p><strong>2. Aporte Mensal Ideal:</strong> ${formatMoney(analysisContribution.value)}</p>`;
      resultHTML += `<p><strong>3. Tempo Necessário:</strong> ${formatMonths(analysisTime.value)}</p>`;
      resultHTML += `<p><strong>4. Rentabilidade Anual Ideal:</strong> ${formatRate(analysisRate.value)}</p>`;
      resultHTML += `<p><i>(Veja detalhes, gráficos e memórias de cálculo de cada análise abaixo)</i></p>`;

      resultDiv.innerHTML = resultHTML;
      resultDiv.style.display = "block";

      // --- Exibir Gráficos e Tabelas das Análises Adicionais ---

      // Análise 1: Valor Inicial
      const initialValueContainer = document.getElementById("analysisInitialValueContainer");
      const resultInitialValueP = document.getElementById("resultInitialValue");
      resultInitialValueP.textContent = `Valor Inicial Necessário (sem aportes): ${formatMoney(analysisInitial.value)}`;
      if (analysisInitial.simulation && analysisInitial.simulation.valoresMensais) {
          drawInitialValueChart(analysisInitial.simulation.valoresMensais);
          fillDataTable("tableInitialValue", analysisInitial.simulation.valoresMensais);
          initialValueContainer.style.display = "block";
          showChartSlide("InitialValue", "chart");
      } else {
          initialValueContainer.style.display = "none";
      }

      // Análise 2: Aporte Ideal
      const idealContributionContainer = document.getElementById("analysisIdealContributionContainer");
      const resultIdealContributionP = document.getElementById("resultIdealContribution");
      resultIdealContributionP.textContent = `Aporte Mensal Ideal: ${formatMoney(analysisContribution.value)}`;
      if (analysisContribution.simulation && analysisContribution.simulation.valoresMensais) {
          drawIdealContributionChart(analysisContribution.simulation.valoresMensais);
          fillDataTable("tableIdealContribution", analysisContribution.simulation.valoresMensais);
          idealContributionContainer.style.display = "block";
          showChartSlide("IdealContribution", "chart");
      } else {
           idealContributionContainer.style.display = "none";
      }

      // Análise 3: Tempo Necessário
      const requiredTimeContainer = document.getElementById("analysisRequiredTimeContainer");
      const resultRequiredTimeP = document.getElementById("resultRequiredTime");
      resultRequiredTimeP.textContent = `Tempo Necessário: ${formatMonths(analysisTime.value)}`;
      if (analysisTime.simulation && analysisTime.simulation.valoresMensais) {
          // A simulação pode ser longa se o tempo for Infinity, limitar exibição?
          // Por ora, exibimos tudo.
          drawRequiredTimeChart(analysisTime.simulation.valoresMensais);
          fillDataTable("tableRequiredTime", analysisTime.simulation.valoresMensais);
          requiredTimeContainer.style.display = "block";
          showChartSlide("RequiredTime", "chart");
      } else {
          requiredTimeContainer.style.display = "none";
      }

      // Análise 4: Taxa Ideal
      const idealRateContainer = document.getElementById("analysisIdealRateContainer");
      const resultIdealRateP = document.getElementById("resultIdealRate");
      resultIdealRateP.textContent = `Rentabilidade Anual Ideal: ${formatRate(analysisRate.value)}`;
      if (analysisRate.simulation && analysisRate.simulation.valoresMensais) {
          drawIdealRateChart(analysisRate.simulation.valoresMensais);
          fillDataTable("tableIdealRate", analysisRate.simulation.valoresMensais);
          idealRateContainer.style.display = "block";
          showChartSlide("IdealRate", "chart");
      } else {
          idealRateContainer.style.display = "none";
      }

      // Gerar recomendação baseada na simulação principal
      generateRecommendation(recommendationDetails, currentContribution);

      // Desenhar gráfico e preencher tabela de projeção principal
      drawProjectionChart(valoresMensais);
      fillDataTable("tableProjection", valoresMensais);
      document.getElementById("projectionChartContainer").style.display = "block";
      showChartSlide("Projection", "chart"); // Mostrar gráfico por padrão

      // Armazenar dados do cálculo atual para salvar cenário
      currentCalculationData = {
        objectives: JSON.parse(JSON.stringify(objectives)), // Deep copy
        currentSavings,
        currentContribution,
        rate: rateType === "annual" ? rateInput : monthlyRate, // Salvar a taxa original informada
        rateType,
        tax,
        inflation: annualInflation, // Salvar inflação anual
        calculationResult: projection, // Salvar os resultados da projeção principal
        additionalAnalysis: { // Salvar resultados das análises adicionais (incluindo simulações)
            requiredInitial: analysisInitial,
            idealContribution: analysisContribution,
            requiredTime: analysisTime,
            idealAnnualRate: analysisRate
        },
        maxPeriod // Salvar o período máximo usado
      };

      // Mostrar botões de ação
      document.getElementById("saveScenarioButton").style.display = "block";
      document.getElementById("newScenarioButton").style.display = "block";
      document.getElementById("whatsappButton").style.display = "block";
      if (scenarios.length >= 1) { // Mostrar botão de análise se já houver cenários salvos
          document.getElementById("analyzeScenarioButton").style.display = "block";
      }
    }

    // --- Funções de Análise e Recomendação ---
    function generateRecommendation(objectiveResults, currentContribution) {
      const recommendationDiv = document.getElementById("recommendation");
      const recommendationText = document.getElementById("recommendationText");
      let analysis = "";
      let allMet = true;
      let suggestions = [];

      objectiveResults.forEach(res => {
        if (!res.met) {
          allMet = false;
          const shortfall = res.targetValue - res.netValue;
          analysis += `<p>O objetivo "${res.description}" não foi atingido no prazo de ${res.period} meses. Faltaram ${formatMoney(shortfall)}.</p>`;
        }
      });

      if (allMet) {
        analysis += "<p><strong>Parabéns!</strong> Com base nos parâmetros informados, todos os seus objetivos são atingidos dentro dos prazos definidos.</p>";
      } else {
        analysis += "<p><strong>Atenção:</strong> Alguns objetivos não foram atingidos. Considere as seguintes sugestões:</p>";
        // Sugestões (simplificadas)
        suggestions.push("Aumentar o aporte mensal.");
        suggestions.push("Buscar investimentos com maior rentabilidade (lembre-se do risco!).");
        suggestions.push("Aumentar o prazo para os objetivos não atingidos.");
        suggestions.push("Reduzir o valor dos objetivos não atingidos.");
        suggestions.push("Aumentar o valor inicial (se possível).");

        analysis += "<ul>";
        suggestions.forEach(s => { analysis += `<li>${s}</li>`; });
        analysis += "</ul>";
        analysis += "<p>Use as análises adicionais abaixo (Valor Inicial, Aporte Ideal, Tempo Necessário, Taxa Ideal) para explorar cenários alternativos.</p>"
      }

      recommendationText.innerHTML = analysis;
      recommendationDiv.style.display = "block";
    }

    // --- Funções de Gráficos e Tabelas ---
    function drawGenericChart(canvasId, chartInstanceRef, valoresMensais, chartTitle) {
        const ctx = document.getElementById(canvasId).getContext("2d");
        const labels = valoresMensais.map(v => v.month);
        const bruto = valoresMensais.map(v => v.totalAcumulado);
        const liquido = valoresMensais.map(v => v.valorLiquido);
        const investido = valoresMensais.map(v => v.totalInvestido);

        // Destruir gráfico existente se houver
        if (chartInstanceRef && chartInstanceRef.chart) {
            chartInstanceRef.chart.destroy();
        }

        const newChart = new Chart(ctx, {
            type: "line",
            data: {
                labels: labels,
                datasets: [
                    {
                        label: "Valor Bruto",
                        data: bruto,
                        borderColor: "rgba(4, 108, 78, 0.8)", // Verde Esmeralda
                        backgroundColor: "transparent",
                        borderWidth: 2, pointRadius: 0, pointHoverRadius: 5, tension: 0.1
                    },
                    {
                        label: "Valor Líquido (após IR)",
                        data: liquido,
                        borderColor: "rgba(212, 175, 55, 0.8)", // Dourado
                        backgroundColor: "transparent",
                        borderWidth: 2, pointRadius: 0, pointHoverRadius: 5, tension: 0.1
                    },
                    {
                        label: "Total Investido",
                        data: investido,
                        borderColor: "rgba(111, 66, 193, 0.6)", // Roxo
                        backgroundColor: "transparent",
                        borderWidth: 2, borderDash: [5, 5], pointRadius: 0, pointHoverRadius: 5, tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: { callback: function(value) { return formatMoney(value); } }
                    },
                    x: { title: { display: true, text: 'Meses' } }
                },
                plugins: {
                    title: { display: false }, // Use o título do container HTML
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) { label += ': '; }
                                if (context.parsed.y !== null) { label += formatMoney(context.parsed.y); }
                                return label;
                            }
                        }
                    },
                    legend: { position: 'top' }
                }
            }
        });
        // Armazena a referência ao novo gráfico
        chartInstanceRef.chart = newChart;
    }

    // Wrapper para o gráfico de projeção principal
    function drawProjectionChart(valoresMensais) {
        drawGenericChart("chartProjection", { get chart() { return projectionChart; }, set chart(v) { projectionChart = v; } }, valoresMensais, "Evolução da Projeção Financeira");
    }

    // Wrapper para o gráfico de Valor Inicial Necessário
    function drawInitialValueChart(valoresMensais) {
        drawGenericChart("chartInitialValue", { get chart() { return initialValueChart; }, set chart(v) { initialValueChart = v; } }, valoresMensais, "Evolução - Valor Inicial Necessário");
    }

     // Wrapper para o gráfico de Aporte Mensal Ideal
    function drawIdealContributionChart(valoresMensais) {
        drawGenericChart("chartIdealContribution", { get chart() { return idealContributionChart; }, set chart(v) { idealContributionChart = v; } }, valoresMensais, "Evolução - Aporte Mensal Ideal");
    }

    // Wrapper para o gráfico de Tempo Necessário
    function drawRequiredTimeChart(valoresMensais) {
        drawGenericChart("chartRequiredTime", { get chart() { return requiredTimeChart; }, set chart(v) { requiredTimeChart = v; } }, valoresMensais, "Evolução - Tempo Necessário");
    }

    // Wrapper para o gráfico de Rentabilidade Anual Ideal
    function drawIdealRateChart(valoresMensais) {
        drawGenericChart("chartIdealRate", { get chart() { return idealRateChart; }, set chart(v) { idealRateChart = v; } }, valoresMensais, "Evolução - Rentabilidade Anual Ideal");
    }

    function fillDataTable(tableId, data) {
      const table = document.getElementById(tableId);
      const tbody = table.querySelector("tbody");
      tbody.innerHTML = ""; // Limpar tabela

      if (!data || data.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;">Nenhum dado para exibir.</td></tr>';
        return;
      }

      data.forEach(row => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td style="text-align:center;">${row.month}</td>
          <td>${formatMoney(row.totalInvestido)}</td>
          <td>${formatMoney(row.juros)}</td>
          <td>${formatMoney(row.totalJuros)}</td>
          <td>${formatMoney(row.totalAcumulado)}</td>
          <td>${formatMoney(row.imposto)}</td>
          <td>${formatMoney(row.valorLiquido)}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    // --- Funções de Gerenciamento de Cenários ---
    function addCurrentScenario() {
      if (!currentCalculationData) {
        alert("Calcule um cenário primeiro antes de salvar.");
        return;
      }

      const scenarioName = prompt(`Digite um nome para este cenário (ou deixe em branco para nome automático):`, `Cenário ${scenarioCounter}`);
      if (scenarioName === null) return; // User cancelled

      const nameToUse = scenarioName.trim() === "" ? `Cenário ${scenarioCounter}` : scenarioName.trim();

      scenarios.push({ name: nameToUse, data: currentCalculationData });
      scenarioCounter++;
      displayScenarios();
      document.getElementById("analyzeScenarioButton").style.display = "block"; // Show analyze button
    }

    function displayScenarios() {
      const scenariosListDiv = document.getElementById("scenariosList");
      scenariosListDiv.innerHTML = "";
      document.getElementById("scenariosContainer").style.display = scenarios.length > 0 ? "block" : "none";

      scenarios.forEach((scenario, index) => {
        const card = document.createElement("div");
        card.className = "scenario-card";
        card.innerHTML = `
          <div class="scenario-header">
            <h4 class="scenario-title">${scenario.name}</h4>
            <div class="scenario-actions">
              <button class="scenario-select" onclick="selectScenario(${index})">Selecionar</button>
              <button class="scenario-delete" onclick="deleteScenario(${index})">Excluir</button>
            </div>
          </div>
          <div class="scenario-content">
            <div class="scenario-info">
              <p><strong>Valor Inicial:</strong> ${formatMoney(scenario.data.currentSavings)}</p>
              <p><strong>Aporte Mensal:</strong> ${formatMoney(scenario.data.currentContribution)}</p>
              <p><strong>Taxa:</strong> ${formatRate(scenario.data.rateType === 'annual' ? scenario.data.rate : Math.pow(1+scenario.data.rate,12)-1)} (${scenario.data.rateType === 'annual' ? 'Anual' : 'Mensal'})</p>
              <p><strong>Imposto:</strong> ${(scenario.data.tax * 100).toFixed(2)}%</p>
              <p><strong>Inflação Anual:</strong> ${(scenario.data.inflation * 100).toFixed(2)}%</p>
              <p><strong>Período Simulado:</strong> ${scenario.data.maxPeriod} meses</p>
            </div>
            <div class="scenario-details">
              <strong>Objetivos:</strong>
              <ul>
                ${scenario.data.objectives.map(obj => `<li>${obj.description} - ${formatMoney(obj.value)} em ${obj.period} meses</li>`).join('')}
              </ul>
            </div>
          </div>
        `;
        scenariosListDiv.appendChild(card);
      });
    }

    function deleteScenario(index) {
      if (confirm(`Tem certeza que deseja excluir o cenário "${scenarios[index].name}"?`)) {
        scenarios.splice(index, 1);
        displayScenarios();
        if (scenarios.length < 1) {
          document.getElementById("analyzeScenarioButton").style.display = "none";
          document.getElementById("comparisonContainer").style.display = "none";
          document.getElementById("generalAnalysis").style.display = "none";
        }
      }
    }

    function selectScenario(index) {
      const scenarioData = scenarios[index].data;

      // Preencher formulário
      document.getElementById("currentSavings").value = formatMoney(scenarioData.currentSavings);
      document.getElementById("currentContribution").value = formatMoney(scenarioData.currentContribution);
      document.getElementById("rate").value = formatPercentage(scenarioData.rate * 100);
      document.getElementById("rateType").value = scenarioData.rateType;
      document.getElementById("tax").value = formatPercentage(scenarioData.tax * 100);
      document.getElementById("inflation").value = formatPercentage(scenarioData.inflation * 100);
      // Habilitar/desabilitar campos de taxa/inflação se necessário (assumindo que o usuário sabia)
      document.getElementById("knowsTax").value = "yes";
      document.getElementById("tax").disabled = false;
      document.getElementById("knowsInflation").value = "yes";
      document.getElementById("inflation").disabled = false;

      // Limpar e preencher objetivos
      objectives = JSON.parse(JSON.stringify(scenarioData.objectives)); // Deep copy
      displayObjectives();

      // Recalcular e exibir resultados para este cenário
      calculateSavings();

      // Marcar card como ativo (opcional)
      document.querySelectorAll('.scenario-card').forEach((card, i) => {
        card.classList.toggle('active', i === index);
      });

      alert(`Cenário "${scenarios[index].name}" carregado. Os resultados foram recalculados e exibidos.`);
    }

    function prepareNewScenario() {
      // Limpar formulário
      document.getElementById("savingsForm").reset();
      // Resetar campos de taxa/inflação para padrão 'Não sei'
      toggleTaxInput('tax', '15,00 %');
      toggleTaxInput('inflation', '5,00 %');
      // Limpar objetivos
      objectives = [];
      displayObjectives();
      // Limpar resultados e gráficos
      document.getElementById("result").style.display = "none";
      document.getElementById("recommendation").style.display = "none";
      document.getElementById("projectionChartContainer").style.display = "none";
      clearAnalysisResults(); // Limpa as 4 análises adicionais
      document.getElementById("comparisonContainer").style.display = "none";
      document.getElementById("generalAnalysis").style.display = "none";
      // Esconder botões de ação (exceto o de análise se houver cenários)
      document.getElementById("saveScenarioButton").style.display = "none";
      document.getElementById("newScenarioButton").style.display = "none";
      document.getElementById("whatsappButton").style.display = "none";
      currentCalculationData = null;
    }

    function clearAnalysisResults() {
        const analysisContainers = [
            "analysisInitialValueContainer",
            "analysisIdealContributionContainer",
            "analysisRequiredTimeContainer",
            "analysisIdealRateContainer"
        ];
        analysisContainers.forEach(id => {
            const container = document.getElementById(id);
            if (container) container.style.display = "none";
            // Opcional: Limpar tabelas e destruir gráficos aqui se necessário
            // Mas como eles são recriados a cada cálculo, apenas esconder pode ser suficiente.
        });
    }

    // --- Funções de Comparação de Cenários ---
    function analyzeScenarios() {
      if (scenarios.length < 1) {
        alert("Salve pelo menos um cenário para comparar.");
        return;
      }

      // Selecionar cenários para comparar (aqui comparamos todos os salvos)
      const scenariosToCompare = scenarios;

      drawComparisonChart(scenariosToCompare);
      fillComparisonTable(scenariosToCompare);
      generateGeneralAnalysis(scenariosToCompare);

      document.getElementById("comparisonContainer").style.display = "block";
      document.getElementById("generalAnalysis").style.display = "block";
    }

    function drawComparisonChart(scenariosToCompare) {
      const ctx = document.getElementById("comparisonChart").getContext("2d");
      const datasets = [];
      let maxMonths = 0;

      scenariosToCompare.forEach((scenario, index) => {
        const data = scenario.data.calculationResult.valoresMensais;
        const color = `hsl(${(index * 60) % 360}, 70%, 50%)`; // Cores variadas
        datasets.push({
          label: scenario.name,
          data: data.map(d => d.valorLiquido),
          borderColor: color,
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: 0,
          tension: 0.1
        });
        maxMonths = Math.max(maxMonths, data.length - 1);
      });

      const labels = Array.from({ length: maxMonths + 1 }, (_, i) => i);

      if (comparisonChart) {
        comparisonChart.destroy();
      }

      comparisonChart = new Chart(ctx, {
        type: 'line',
        data: { labels: labels, datasets: datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: { beginAtZero: true, ticks: { callback: value => formatMoney(value) } },
            x: { title: { display: true, text: 'Meses' } }
          },
          plugins: {
            title: { display: true, text: 'Comparação de Valor Líquido Acumulado' },
            tooltip: { callbacks: { label: context => `${context.dataset.label}: ${formatMoney(context.parsed.y)}` } },
            legend: { position: 'top' }
          }
        }
      });
    }

    function fillComparisonTable(scenariosToCompare) {
      const table = document.getElementById("comparisonTable");
      const thead = table.querySelector("thead");
      const tbody = table.querySelector("tbody");
      thead.innerHTML = "";
      tbody.innerHTML = "";

      // Cabeçalho
      let headerRow = "<tr><th>Métrica</th>";
      scenariosToCompare.forEach(s => { headerRow += `<th>${s.name}</th>`; });
      headerRow += "</tr>";
      thead.innerHTML = headerRow;

      // Métricas a comparar
      const metrics = [
        { key: 'finalNetValue', label: 'Valor Líquido Final', format: formatMoney },
        { key: 'totalInvested', label: 'Total Investido', format: formatMoney },
        { key: 'totalInterest', label: 'Total Juros Brutos', format: formatMoney },
        { key: 'totalTax', label: 'Total Imposto Pago', format: formatMoney },
        { key: 'requiredInitial', label: 'Valor Inicial Necessário', format: formatMoney, source: 'additionalAnalysis.requiredInitial.value' },
        { key: 'idealContribution', label: 'Aporte Mensal Ideal', format: formatMoney, source: 'additionalAnalysis.idealContribution.value' },
        { key: 'requiredTime', label: 'Tempo Necessário', format: formatMonths, source: 'additionalAnalysis.requiredTime.value' },
        { key: 'idealRate', label: 'Taxa Anual Ideal', format: formatRate, source: 'additionalAnalysis.idealAnnualRate.value' }
      ];

      metrics.forEach(metric => {
        let row = `<tr><td>${metric.label}</td>`;
        let values = [];
        scenariosToCompare.forEach(s => {
          let value;
          if (metric.source) {
            // Acessar valor aninhado
            const keys = metric.source.split('.');
            value = keys.reduce((obj, key) => (obj && obj[key] !== undefined) ? obj[key] : undefined, s.data);
          } else {
             // Acessar valor direto do resultado principal (último mês)
             const result = s.data.calculationResult;
             const lastMonthData = result.valoresMensais[result.valoresMensais.length - 1];
             switch(metric.key) {
                 case 'finalNetValue': value = lastMonthData.valorLiquido; break;
                 case 'totalInvested': value = lastMonthData.totalInvestido; break;
                 case 'totalInterest': value = lastMonthData.totalJuros; break;
                 case 'totalTax': value = lastMonthData.imposto; break;
                 default: value = undefined;
             }
          }
          values.push(value);
        });

        // Encontrar melhor e pior valor (assumindo que maior é melhor, exceto para imposto e tempo)
        let numericValues = values.filter(v => typeof v === 'number' && isFinite(v));
        let bestValue = -Infinity, worstValue = Infinity;
        if (numericValues.length > 0) {
            if (['totalTax', 'requiredTime'].includes(metric.key)) { // Menor é melhor
                bestValue = Math.min(...numericValues);
                worstValue = Math.max(...numericValues);
            } else { // Maior é melhor
                bestValue = Math.max(...numericValues);
                worstValue = Math.min(...numericValues);
            }
        }

        values.forEach(value => {
          let formattedValue = metric.format(value);
          let className = '';
          if (typeof value === 'number' && isFinite(value)) {
              if (value === bestValue && bestValue !== worstValue) className = 'best-value';
              if (value === worstValue && bestValue !== worstValue) className = 'worst-value';
          }
          row += `<td class="${className}">${formattedValue}</td>`;
        });

        row += "</tr>";
        tbody.innerHTML += row;
      });
    }

    function generateGeneralAnalysis(scenariosToCompare) {
      const analysisDiv = document.getElementById("generalAnalysisText");
      let analysis = "<p>Comparando os cenários:</p><ul>";

      // Exemplo de análise simples: Qual cenário atinge o maior valor líquido final?
      let bestScenarioNetValue = null;
      let maxNetValue = -Infinity;
      scenariosToCompare.forEach(s => {
          const finalValue = s.data.calculationResult.valoresMensais[s.data.calculationResult.valoresMensais.length - 1].valorLiquido;
          if (finalValue > maxNetValue) {
              maxNetValue = finalValue;
              bestScenarioNetValue = s.name;
          }
      });
      if (bestScenarioNetValue) {
          analysis += `<li>O cenário <strong>${bestScenarioNetValue}</strong> resulta no maior valor líquido final (${formatMoney(maxNetValue)}).</li>`;
      }

       // Exemplo: Qual cenário precisa do menor aporte ideal?
      let bestScenarioContribution = null;
      let minContribution = Infinity;
       scenariosToCompare.forEach(s => {
          const contribution = s.data.additionalAnalysis.idealContribution.value;
          if (typeof contribution === 'number' && isFinite(contribution) && contribution < minContribution) {
              minContribution = contribution;
              bestScenarioContribution = s.name;
          }
      });
       if (bestScenarioContribution) {
          analysis += `<li>O cenário <strong>${bestScenarioContribution}</strong> exige o menor aporte mensal ideal (${formatMoney(minContribution)}) para atingir os objetivos.</li>`;
      }

      // Adicionar mais análises comparativas conforme necessário...

      analysis += "</ul><p>Use a tabela acima para comparar outras métricas detalhadamente.</p>";
      analysisDiv.innerHTML = analysis;
    }


    // --- Função WhatsApp ---
    function openWhatsAppChat() {
      if (!currentCalculationData) {
        alert("Por favor, calcule um cenário primeiro.");
        return;
      }

      const data = currentCalculationData;
      let objectivesText = "Objetivos:\n";
      data.objectives.forEach(obj => {
        objectivesText += `- ${obj.description}: ${formatMoney(obj.value)} em ${obj.period} meses\n`;
      });

      let parametersText = "Parâmetros:\n";
      parametersText += `Valor Inicial: ${formatMoney(data.currentSavings)}\n`;
      parametersText += `Aporte Mensal: ${formatMoney(data.currentContribution)}\n`;
      parametersText += `Taxa: ${formatPercentage(data.rate * 100)} (${data.rateType === 'annual' ? 'Anual' : 'Mensal'})\n`;
      parametersText += `Imposto: ${formatPercentage(data.tax * 100)}\n`;
      parametersText += `Inflação Anual: ${formatPercentage(data.inflation * 100)}\n`;

      let analysisText = "Análises Adicionais:\n";
      analysisText += `Valor Inicial Nec.: ${formatMoney(data.additionalAnalysis.requiredInitial.value)}\n`;
      analysisText += `Aporte Ideal: ${formatMoney(data.additionalAnalysis.idealContribution.value)}\n`;
      analysisText += `Tempo Nec.: ${formatMonths(data.additionalAnalysis.requiredTime.value)}\n`;
      analysisText += `Taxa Ideal: ${formatRate(data.additionalAnalysis.idealAnnualRate.value)}\n`;

      // Usar a descrição do primeiro objetivo como contexto
      const goalContext = objectives.length > 0 ? objectives[0].description : "(Objetivo não descrito)";

      const message = `Oi Hugo, queria tua ajuda com meus objetivos:\n${goalContext}\n\n${objectivesText}\n${parametersText}\n${analysisText}\nEstou usando a calculadora que você criou.`;
      const encodedMessage = encodeURIComponent(message);
      const whatsappUrl = `https://api.whatsapp.com/send?phone=5581994297920&text=${encodedMessage}`;
      window.open(whatsappUrl, "_blank");
    }

    // --- Inicialização ---
    document.addEventListener('DOMContentLoaded', (event) => {
        // Inicializar exibição de objetivos (vazia no início)
        displayObjectives();
        // Configurar valores padrão para IR e Inflação
        toggleTaxInput('tax', '15,00 %');
        toggleTaxInput('inflation', '5,00 %');
    });

  </script>
</body>
</html>

