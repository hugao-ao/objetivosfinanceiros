<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Calculadora Sequencial de MÃºltiplos Objetivos</title>
  <link rel="icon" href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script> <!-- Optional: for time scale if needed -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script> <!-- For deadline lines -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    :root {
      --verde-esmeralda: #046c4e;
      --verde-esmeralda-escuro: #034e38;
      --verde-claro: #28a745;
      --verde-medio: #218838;
      --dourado: #d4af37;
      --dourado-claro: #f5e2a9;
      --dourado-escuro: #b38e2e;
      --roxo: #6f42c1;
      --roxo-claro: #9f75e5;
      --roxo-escuro: #4b2882;
      --fundo-claro: #f9f9f9;
      --fundo-container: #ffffff;
      --vermelho-translucido: rgba(255, 0, 0, 0.1);
      --azul-translucido: rgba(0, 0, 255, 0.1);
      --roxo-translucido: rgba(111, 66, 193, 0.1);
      --cinza-claro: #e9ecef;
      --cinza-medio: #ced4da;
      --cinza-escuro: #6c757d;
      --verde-destaque: rgba(4, 108, 78, 0.1);
      --vermelho-destaque: rgba(220, 53, 69, 0.1);
      --sombra-padrao: 0 4px 12px rgba(0,0,0,0.1);
      --borda-arredondada: 8px;
      --espacamento-padrao: 20px;
      --transicao-padrao: all 0.3s ease;
    }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background-color: var(--fundo-claro);
      color: var(--verde-esmeralda-escuro);
      margin: 0;
      padding: var(--espacamento-padrao);
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
      line-height: 1.6;
    }
    h1, h2, h3, h4, h5, h6 {
      color: var(--verde-esmeralda);
      margin-top: 0;
      margin-bottom: var(--espacamento-padrao);
      font-weight: 600;
      line-height: 1.3;
    }
    h1 {
      color: var(--verde-esmeralda-escuro);
      text-align: center;
      font-size: 2.2rem;
      margin-bottom: 1.5rem;
      border-bottom: 3px solid var(--dourado);
      padding-bottom: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    form {
      background-color: var(--fundo-container);
      padding: var(--espacamento-padrao);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
      margin-bottom: var(--espacamento-padrao);
      border: 1px solid var(--cinza-claro);
    }
    .result {
      margin-top: var(--espacamento-padrao);
      padding: var(--espacamento-padrao);
      border: 2px solid var(--dourado);
      background-color: var(--fundo-container);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
    }
    .result h4 {
        color: var(--verde-esmeralda-escuro);
        border-bottom: 1px solid var(--dourado-claro);
        padding-bottom: 10px;
        margin-bottom: 15px;
    }
    .recommendation {
      margin: var(--espacamento-padrao) 0;
      padding: var(--espacamento-padrao);
      border: 2px solid var(--verde-esmeralda);
      background-color: var(--fundo-container);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
    }
    .recommendation h3 {
      color: var(--verde-esmeralda-escuro);
      margin-top: 0;
      border-bottom: 2px solid var(--dourado);
      padding-bottom: 10px;
      font-size: 1.4rem;
    }
    .whatsapp-button {
      display: block;
      width: 100%;
      padding: 15px;
      margin: var(--espacamento-padrao) 0;
      background-color: var(--verde-esmeralda);
      color: white;
      text-align: center;
      font-weight: bold;
      font-size: 1.2rem;
      border: none;
      border-radius: var(--borda-arredondada);
      cursor: pointer;
      text-decoration: none;
      box-shadow: var(--sombra-padrao);
      transition: var(--transicao-padrao);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .whatsapp-button:hover {
      background-color: var(--verde-esmeralda-escuro);
      transform: translateY(-2px);
    }
    .save-scenario-button, .analyze-scenario-button, .new-scenario-button {
      display: block;
      width: 100%;
      padding: 15px;
      margin: var(--espacamento-padrao) 0;
      color: white;
      text-align: center;
      font-weight: bold;
      font-size: 1rem;
      border: none;
      border-radius: var(--borda-arredondada);
      cursor: pointer;
      text-decoration: none;
      box-shadow: var(--sombra-padrao);
      transition: var(--transicao-padrao);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .save-scenario-button { background-color: var(--dourado); }
    .save-scenario-button:hover { background-color: var(--dourado-escuro); transform: translateY(-2px); }
    .analyze-scenario-button { background-color: var(--verde-esmeralda); }
    .analyze-scenario-button:hover { background-color: var(--verde-esmeralda-escuro); transform: translateY(-2px); }
    .new-scenario-button { background-color: var(--dourado); }
    .new-scenario-button:hover { background-color: var(--dourado-escuro); transform: translateY(-2px); }

    label {
      display: block;
      margin-top: 15px;
      margin-bottom: 5px;
      font-weight: 500;
      color: var(--verde-esmeralda-escuro);
    }
    .row {
      display: flex;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      justify-content: space-between;
      gap: 15px;
      margin-bottom: 15px;
    }
    .row > div {
      flex: 1;
      min-width: 150px; /* Prevent fields from becoming too narrow */
    }
    input, select, textarea {
      width: 100%;
      padding: 12px;
      margin-top: 5px;
      box-sizing: border-box;
      border: 1px solid var(--cinza-medio);
      border-radius: var(--borda-arredondada);
      transition: var(--transicao-padrao);
      font-size: 1rem;
    }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--dourado);
      box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
    }
    textarea {
      min-height: 80px; /* Reduced height */
      resize: vertical;
    }
    button {
      margin-top: 20px;
      padding: 14px;
      background-color: var(--verde-esmeralda);
      color: white;
      border: none;
      border-radius: var(--borda-arredondada);
      cursor: pointer;
      width: 100%;
      font-weight: bold;
      font-size: 1rem;
      transition: var(--transicao-padrao);
      letter-spacing: 0.5px;
    }
    button:hover {
      background-color: var(--verde-esmeralda-escuro);
      transform: translateY(-2px);
    }
    .chart-container {
      margin-top: 30px;
      position: relative;
      border: 2px solid var(--dourado-claro);
      border-radius: var(--borda-arredondada);
      padding: 20px;
      background-color: var(--fundo-container);
      box-shadow: var(--sombra-padrao);
    }
    .chart-title {
      text-align: center;
      font-weight: bold;
      margin-bottom: 20px;
      color: var(--verde-esmeralda-escuro);
      font-size: 1.2rem;
      border-bottom: 1px solid var(--dourado);
      padding-bottom: 10px;
    }
    .chart-nav {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 15px;
    }
    .chart-nav button {
      padding: 10px 20px;
      margin-top: 0;
      width: auto;
      font-size: 0.9rem;
      background-color: var(--dourado);
      border-radius: var(--borda-arredondada);
      transition: var(--transicao-padrao);
    }
    .chart-nav button:hover {
      background-color: var(--dourado-escuro);
    }
    .chart-content {
      display: flex;
      overflow: hidden;
      position: relative;
      height: 400px;
      border: 1px solid var(--cinza-claro);
      border-radius: var(--borda-arredondada);
      background-color: var(--fundo-container);
    }
    .chart-slide {
      flex: 0 0 100%;
      transition: transform 0.3s ease;
    }
    .table-slide {
      flex: 0 0 100%;
      overflow-x: auto;
      overflow-y: auto;
      padding: 15px;
      background-color: var(--fundo-container);
      max-height: 400px; /* Limit table height */
    }
    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      min-width: 800px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    .data-table th, .data-table td {
      border: 1px solid var(--cinza-claro);
      padding: 10px;
      text-align: right;
      white-space: nowrap;
    }
    .data-table th {
      background-color: var(--verde-esmeralda);
      color: white;
      font-weight: 600;
      text-align: center;
      text-transform: uppercase;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .data-table tr:nth-child(even) {
      background-color: var(--verde-destaque);
    }
    .data-table tr:hover {
      background-color: var(--dourado-claro);
    }
    .data-table .objective-deadline-row td {
        background-color: var(--dourado-claro) !important;
        font-weight: bold;
        border-top: 2px solid var(--dourado-escuro);
        border-bottom: 2px solid var(--dourado-escuro);
    }
    .scenarios-container {
      margin: 30px 0;
      padding: 20px;
      border: 2px solid var(--dourado);
      background-color: var(--fundo-container);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
    }
    .scenarios-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 2px solid var(--verde-esmeralda);
      padding-bottom: 10px;
    }
    .scenarios-header h3 {
      color: var(--verde-esmeralda-escuro);
      margin: 0;
      font-size: 1.4rem;
    }
    .scenario-card {
      border: 1px solid var(--cinza-medio);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      background-color: var(--cinza-claro);
      position: relative;
    }
    .scenario-card.active {
      border: 2px solid var(--verde-esmeralda);
      background-color: white;
    }
    .scenario-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .scenario-title {
      font-weight: bold;
      color: var(--verde-esmeralda);
      margin: 0;
    }
    .scenario-actions {
      display: flex;
      gap: 10px;
    }
    .scenario-actions button {
      padding: 5px 10px;
      margin: 0;
      width: auto;
      font-size: 12px;
    }
    .scenario-delete {
      background-color: #dc3545;
    }
    .scenario-delete:hover {
      background-color: #c82333;
    }
    .scenario-select {
      background-color: var(--dourado);
    }
    .scenario-select:hover {
      background-color: var(--dourado-escuro);
    }
    .scenario-content {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .scenario-info {
      flex: 1;
      min-width: 200px;
    }
    .scenario-info p {
      margin: 5px 0;
    }
    .scenario-info strong {
      color: var(--verde-esmeralda);
    }
    .scenario-details {
      margin-top: 10px;
      padding: 10px;
      background-color: var(--fundo-claro);
      border-radius: 5px;
      font-size: 14px;
    }
    .scenario-details ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .scenario-details li {
      margin-bottom: 5px;
    }
    /* Estilos para comparaÃ§Ã£o de cenÃ¡rios */
    .comparison-container {
      margin-top: 30px;
      border: 2px solid var(--roxo);
      border-radius: 8px;
      padding: 15px;
      background-color: white;
    }
    .comparison-header {
      color: var(--roxo);
      margin-top: 0;
      border-bottom: 1px solid var(--dourado-claro);
      padding-bottom: 10px;
      text-align: center;
    }
    .comparison-chart-container {
      height: 400px;
      margin: 20px 0;
    }
    #comparisonTableContainer {
      overflow-x: auto; /* Habilitar rolagem horizontal */
    }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      min-width: 900px; /* Garantir largura mÃ­nima para forÃ§ar rolagem se necessÃ¡rio */
    }
    .comparison-table th, .comparison-table td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: center;
      white-space: nowrap; /* Evitar quebra de linha nas cÃ©lulas */
    }
    .comparison-table th {
      background-color: var(--roxo-translucido);
      color: var(--roxo-escuro);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .comparison-table tr:nth-child(even) {
      background-color: var(--fundo-claro);
    }
    .comparison-table .best-value {
      font-weight: bold;
      color: var(--verde-esmeralda);
      background-color: var(--verde-destaque);
    }
    .comparison-table .worst-value {
      font-weight: bold;
      color: #dc3545;
      background-color: var(--vermelho-destaque);
    }
    .general-analysis {
      margin-top: 30px;
      padding: 20px;
      border: 2px solid var(--roxo);
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .general-analysis h3 {
      color: var(--roxo);
      margin-top: 0;
      border-bottom: 1px solid var(--dourado-claro);
      padding-bottom: 10px;
      text-align: center;
    }

    /* Estilos para a seÃ§Ã£o de mÃºltiplos objetivos */
    .objectives-section {
      background-color: var(--fundo-container);
      padding: var(--espacamento-padrao);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
      margin-bottom: var(--espacamento-padrao);
      border: 1px solid var(--cinza-claro);
    }
    .objectives-section h3 {
      color: var(--verde-esmeralda);
      margin-top: 0;
      margin-bottom: 15px;
      border-bottom: 2px solid var(--dourado);
      padding-bottom: 10px;
    }
    .objective-input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      align-items: flex-end; /* Align items to bottom for button */
      margin-bottom: 15px;
    }
    .objective-input-group > div {
      flex: 1;
      min-width: 120px;
    }
    .objective-input-group button {
      flex-basis: 100px; /* Fixed width for button */
      margin-top: 0; /* Remove default top margin */
      padding: 12px; /* Match input padding */
      height: 46px; /* Match input height */
      font-size: 0.9rem;
      width: auto;
    }
    #objectivesList {
      margin-top: 15px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--cinza-medio);
      border-radius: var(--borda-arredondada);
      padding: 10px;
    }
    .objective-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid var(--cinza-claro);
      background-color: var(--fundo-claro);
      border-radius: 4px;
      margin-bottom: 5px;
    }
    .objective-item:last-child {
      border-bottom: none;
    }
    .objective-item span {
      flex-grow: 1;
      margin-right: 10px;
      font-size: 0.9rem;
    }
    .objective-item button {
      padding: 4px 8px;
      margin: 0;
      width: auto;
      font-size: 0.8rem;
      background-color: #dc3545;
      line-height: 1;
    }
    .objective-item button:hover {
      background-color: #c82333;
    }

    /* Analysis sections */
    .analysis-section {
        margin-top: 20px;
        padding: 15px;
        border: 1px solid var(--cinza-medio);
        border-radius: var(--borda-arredondada);
        background-color: var(--fundo-claro);
    }
    .analysis-section h5 {
        color: var(--verde-esmeralda-escuro);
        margin-bottom: 10px;
        font-size: 1.1rem;
    }
    .analysis-section .value {
        font-weight: bold;
        color: var(--verde-esmeralda);
        font-size: 1.2rem;
        margin-bottom: 15px;
        display: block;
    }
    .analysis-chart-container {
        height: 300px; /* Smaller charts for analysis */
        margin-top: 15px;
    }
    .analysis-table-container {
        max-height: 300px;
        overflow-y: auto;
        margin-top: 15px;
    }

  </style>
</head>
<body>
  <h1>Calculadora Sequencial de MÃºltiplos Objetivos</h1>

  <!-- SeÃ§Ã£o para Adicionar/Gerenciar Objetivos -->
  <div class="objectives-section">
    <h3>Seus Objetivos</h3>
    <div class="objective-input-group">
      <div>
        <label for="newObjectiveDescription">DescriÃ§Ã£o</label>
        <input type="text" id="newObjectiveDescription" placeholder="Ex: Viagem Europa">
      </div>
      <div>
        <label for="newObjectiveValue">Valor (R$)</label>
        <input type="text" id="newObjectiveValue" placeholder="R$ 15.000,00" oninput="formatCurrency(this)">
      </div>
      <div>
        <label for="newObjectivePeriod">Prazo (meses)</label>
        <input type="number" id="newObjectivePeriod" placeholder="24" min="1">
      </div>
      <button type="button" onclick="addObjective()">Adicionar</button>
    </div>
    <label>Objetivos Adicionados:</label>
    <div id="objectivesListContainer">
        <div id="objectivesList">
            Nenhum objetivo adicionado ainda.
        </div>
    </div>
  </div>

  <!-- FormulÃ¡rio de ParÃ¢metros Financeiros -->
  <form id="calculatorForm">
    <h3>ParÃ¢metros Financeiros</h3>
    <div class="row">
      <div>
        <label for="initialSavings">Valor jÃ¡ Guardado (R$):</label>
        <input type="text" id="initialSavings" value="R$ 1.000,00" oninput="formatCurrency(this)">
      </div>
      <div>
        <label for="monthlyContribution">Quanto vocÃª poupa atualmente por mÃªs (R$):</label>
        <input type="text" id="monthlyContribution" value="R$ 500,00" oninput="formatCurrency(this)">
      </div>
    </div>
    <div class="row">
      <div>
        <label for="interestRate">Taxa de Juros (%):</label>
        <input type="text" id="interestRate" value="1,0" oninput="formatPercentage(this)">
      </div>
      <div>
        <label for="interestRateType">Tipo de Taxa:</label>
        <select id="interestRateType">
          <option value="mensal" selected>Mensal</option>
          <option value="anual">Anual</option>
        </select>
      </div>
    </div>
    <div class="row">
      <div>
        <label for="taxRate">AlÃ­quota de Imposto de Renda (% sobre o rendimento):</label>
        <input type="text" id="taxRate" value="15,0" oninput="formatPercentage(this)">
      </div>
      <div>
        <label for="annualInflation">InflaÃ§Ã£o Anual MÃ©dia Esperada (%):</label>
        <input type="text" id="annualInflation" value="5,0" oninput="formatPercentage(this)">
      </div>
    </div>
    <button type="button" onclick="calculateSavings()">Calcular ProjeÃ§Ã£o Sequencial</button>
  </form>

  <!-- Container para Resultados e GrÃ¡ficos -->
  <div id="resultsContainer" style="display: none;">
    <div class="result">
      <div id="resultSummary"></div>

      <!-- GrÃ¡fico/Tabela da ProjeÃ§Ã£o Principal -->
      <div class="chart-container" id="projectionChartContainer">
        <div class="chart-title">ProjeÃ§Ã£o Principal Sequencial</div>
        <div class="chart-nav">
          <button onclick="showChart('chartProjection')">GrÃ¡fico</button>
          <button onclick="showTable('tableProjection')">MemÃ³ria de CÃ¡lculo</button>
        </div>
        <div class="chart-content">
          <div class="chart-slide" id="chartProjectionSlide">
            <canvas id="projectionChart"></canvas>
          </div>
          <div class="table-slide" id="tableProjectionSlide" style="display: none;">
            <div class="table-wrapper">
              <table class="data-table" id="tableProjection"></table>
            </div>
          </div>
        </div>
      </div>

      <!-- SeÃ§Ãµes para AnÃ¡lises Adicionais -->
      <div id="analysisResultsContainer">
        <h4>AnÃ¡lises Adicionais (CenÃ¡rios Ideais):</h4>
        <!-- Valor Inicial NecessÃ¡rio -->
        <div class="analysis-section" id="analysisInitialValueContainer">
            <h5>1. Valor Inicial NecessÃ¡rio (sem aportes)</h5>
            <span class="value" id="analysisInitialValue"></span>
            <div class="chart-nav">
              <button onclick="showChart('chartInitialValue')">GrÃ¡fico</button>
              <button onclick="showTable('tableInitialValue')">MemÃ³ria de CÃ¡lculo</button>
            </div>
            <div class="chart-content">
              <div class="chart-slide" id="chartInitialValueSlide">
                <canvas id="chartInitialValue" class="analysis-chart-container"></canvas>
              </div>
              <div class="table-slide" id="tableInitialValueSlide" style="display: none;">
                <div class="analysis-table-container">
                  <table class="data-table" id="tableInitialValue"></table>
                </div>
              </div>
            </div>
        </div>
        <!-- Aporte Mensal Ideal -->
        <div class="analysis-section" id="analysisContributionContainer">
            <h5>2. Aporte Mensal Ideal</h5>
            <span class="value" id="analysisContributionValue"></span>
             <div class="chart-nav">
              <button onclick="showChart('chartContribution')">GrÃ¡fico</button>
              <button onclick="showTable('tableContribution')">MemÃ³ria de CÃ¡lculo</button>
            </div>
            <div class="chart-content">
              <div class="chart-slide" id="chartContributionSlide">
                 <canvas id="chartContribution" class="analysis-chart-container"></canvas>
              </div>
              <div class="table-slide" id="tableContributionSlide" style="display: none;">
                <div class="analysis-table-container">
                  <table class="data-table" id="tableContribution"></table>
                </div>
              </div>
            </div>
        </div>
        <!-- Tempo NecessÃ¡rio -->
        <div class="analysis-section" id="analysisTimeContainer">
            <h5>3. Tempo NecessÃ¡rio</h5>
            <span class="value" id="analysisTimeValue"></span>
             <div class="chart-nav">
              <button onclick="showChart('chartTime')">GrÃ¡fico</button>
              <button onclick="showTable('tableTime')">MemÃ³ria de CÃ¡lculo</button>
            </div>
            <div class="chart-content">
              <div class="chart-slide" id="chartTimeSlide">
                 <canvas id="chartTime" class="analysis-chart-container"></canvas>
              </div>
              <div class="table-slide" id="tableTimeSlide" style="display: none;">
                <div class="analysis-table-container">
                  <table class="data-table" id="tableTime"></table>
                </div>
              </div>
            </div>
        </div>
        <!-- Rentabilidade Anual Ideal -->
        <div class="analysis-section" id="analysisRateContainer">
            <h5>4. Rentabilidade Anual Ideal</h5>
            <span class="value" id="analysisRateValue"></span>
             <div class="chart-nav">
              <button onclick="showChart('chartRate')">GrÃ¡fico</button>
              <button onclick="showTable('tableRate')">MemÃ³ria de CÃ¡lculo</button>
            </div>
            <div class="chart-content">
              <div class="chart-slide" id="chartRateSlide">
                 <canvas id="chartRate" class="analysis-chart-container"></canvas>
              </div>
              <div class="table-slide" id="tableRateSlide" style="display: none;">
                <div class="analysis-table-container">
                  <table class="data-table" id="tableRate"></table>
                </div>
              </div>
            </div>
        </div>
      </div>

    </div>

    <!-- RecomendaÃ§Ã£o -->
    <div class="recommendation" id="recommendationDiv" style="display: none;">
      <h3>RecomendaÃ§Ã£o</h3>
      <p id="recommendationText"></p>
    </div>

    <!-- BotÃµes de AÃ§Ã£o -->
    <button id="saveScenarioButton" class="save-scenario-button" onclick="addCurrentScenario()" disabled>Salvar CenÃ¡rio Atual</button>
    <a id="whatsappButton" class="whatsapp-button" href="#" target="_blank" style="display: none;">Compartilhar Resumo no WhatsApp</a>

  </div>

  <!-- Container para CenÃ¡rios Salvos -->
  <div class="scenarios-container" id="scenariosContainer" style="display: none;">
    <div class="scenarios-header">
      <h3>CenÃ¡rios Salvos</h3>
      <button id="analyzeScenarioButton" class="analyze-scenario-button" onclick="analyzeScenarios()" disabled style="width: auto; margin: 0; font-size: 0.9rem;">Comparar CenÃ¡rios Selecionados</button>
    </div>
    <div id="savedScenariosList">Nenhum cenÃ¡rio salvo ainda.</div>
  </div>

  <!-- Container para ComparaÃ§Ã£o de CenÃ¡rios -->
  <div class="comparison-container" id="comparisonContainer" style="display: none;">
    <h3 class="comparison-header">ComparaÃ§Ã£o de CenÃ¡rios</h3>
    <div class="comparison-chart-container">
      <canvas id="comparisonChart"></canvas>
    </div>
    <div id="comparisonTableContainer">
        <table class="comparison-table" id="comparisonTable"></table>
    </div>
    <div class="general-analysis" id="generalAnalysisContainer">
        <h3>AnÃ¡lise Geral da ComparaÃ§Ã£o</h3>
        <div id="generalAnalysisContent"></div>
    </div>
    <button class="new-scenario-button" onclick="startNewScenario()">Iniciar Novo CenÃ¡rio</button>
  </div>

<script>
    // --- VariÃ¡veis Globais --- //
    let objectives = []; // Array para armazenar os objetos de objetivo { description, value, period }
    let scenarios = []; // Array para armazenar cenÃ¡rios salvos
    let currentCalculationData = null; // Armazena os dados do Ãºltimo cÃ¡lculo
    let chartInstances = {}; // Armazena instÃ¢ncias dos grÃ¡ficos Chart.js

    // --- FunÃ§Ãµes Auxiliares de FormataÃ§Ã£o e Parsing --- //
    function formatCurrency(input) {
      let value = input.value.replace(/\D/g, '');
      if (!value) {
        input.value = '';
        return;
      }
      value = (parseFloat(value) / 100).toFixed(2);
      input.value = "R$ " + value.replace('.', ',').replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1.');
    }

    function parseCurrency(value) {
      if (!value) return 0;
      return parseFloat(value.replace(/R\$\s?/, '').replace(/\./g, '').replace(',', '.')) || 0;
    }

    function formatPercentage(input) {
        let value = input.value.replace(/[^\d,.]/g, '').replace(',', '.');
        // Permitir apenas um ponto decimal
        const parts = value.split('.');
        if (parts.length > 2) {
            value = parts[0] + '.' + parts.slice(1).join('');
        }
        // Limitar a duas casas decimais apÃ³s o ponto
        if (parts[1] && parts[1].length > 2) {
            value = parts[0] + '.' + parts[1].substring(0, 2);
        }
        input.value = value.replace('.', ','); // Exibir com vÃ­rgula
    }

    function parsePercentage(value) {
        if (!value) return 0;
        return parseFloat(value.replace(',', '.')) / 100 || 0;
    }

    function formatCurrencyValue(value) {
        if (value === null || value === undefined || isNaN(value)) return "N/A";
        if (value === Infinity) return "Infinito";
        return "R$ " + value.toFixed(2).replace('.', ',').replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1.');
    }

    function formatPercentageValue(value) {
        if (value === null || value === undefined || isNaN(value)) return "N/A";
        if (value === Infinity) return "Infinito";
        return (value * 100).toFixed(2).replace('.', ',') + "%";
    }

    // --- FunÃ§Ãµes de Gerenciamento de Objetivos --- //
    function addObjective() {
      const descriptionInput = document.getElementById('newObjectiveDescription');
      const valueInput = document.getElementById('newObjectiveValue');
      const periodInput = document.getElementById('newObjectivePeriod');

      const description = descriptionInput.value.trim();
      const value = parseCurrency(valueInput.value);
      const period = parseInt(periodInput.value);

      if (!description) {
        alert("Por favor, insira uma descriÃ§Ã£o para o objetivo.");
        return;
      }
      if (isNaN(value) || value <= 0) {
        alert("Por favor, insira um valor vÃ¡lido (maior que zero) para o objetivo.");
        return;
      }
      if (isNaN(period) || period <= 0) {
        alert("Por favor, insira um prazo vÃ¡lido em meses (maior que zero) para o objetivo.");
        return;
      }

      objectives.push({ description, value, period });
      renderObjectivesList();

      // Limpar campos
      descriptionInput.value = '';
      valueInput.value = '';
      periodInput.value = '';
    }

    function removeObjective(index) {
      objectives.splice(index, 1);
      renderObjectivesList();
    }

    function renderObjectivesList() {
      const listDiv = document.getElementById('objectivesList');
      if (objectives.length === 0) {
        listDiv.innerHTML = 'Nenhum objetivo adicionado ainda.';
        return;
      }

      listDiv.innerHTML = ''; // Limpar lista
      // Ordenar para exibiÃ§Ã£o (opcional, mas pode ser Ãºtil)
      const sortedForDisplay = [...objectives].sort((a, b) => a.period - b.period);

      sortedForDisplay.forEach((obj, index) => {
        // Encontrar o Ã­ndice original para a funÃ§Ã£o de remoÃ§Ã£o
        const originalIndex = objectives.findIndex(o => o === obj);
        const item = document.createElement('div');
        item.className = 'objective-item';
        item.innerHTML = `
          <span><strong>${obj.description}</strong> - ${formatCurrencyValue(obj.value)} em ${obj.period} meses</span>
          <button type="button" onclick="removeObjective(${originalIndex})">Excluir</button>
        `;
        listDiv.appendChild(item);
      });
    }

    // --- FunÃ§Ãµes de CÃ¡lculo Principal e Auxiliares (Refatoradas para Sequencial) ---

    /**
     * Calcula a projeÃ§Ã£o financeira para um Ãºnico segmento de tempo.
     * @param {number} initialGrossValue Valor bruto inicial para o segmento.
     * @param {number} monthlyContribution Aporte mensal constante.
     * @param {number} monthlyRate Taxa de juros mensal.
     * @param {number} duration Meses de duraÃ§Ã£o do segmento.
     * @param {number} tax AlÃ­quota de imposto sobre o rendimento total GLOBAL.
     * @param {number} annualInflation Taxa de inflaÃ§Ã£o anual (usada para corrigir objetivos, nÃ£o impacta cÃ¡lculo bruto/lÃ­quido aqui diretamente).
     * @param {number} startMonthOffset MÃªs inicial global para este segmento (para numeraÃ§Ã£o correta).
     * @param {number} initialGlobalTotalInvested Valor total jÃ¡ investido no inÃ­cio do segmento (para cÃ¡lculo correto do imposto).
     * @param {number} initialGlobalTotalJuros Juros brutos acumulados atÃ© o inÃ­cio do segmento (para cÃ¡lculo correto do imposto).
     * @returns {object} Objeto com { finalGrossValue, finalNetValue, finalGlobalTotalInvested, finalGlobalTotalJuros, valoresMensaisSegment }
     */
    function calculateSegmentSimulation(initialGrossValue, monthlyContribution, monthlyRate, duration, tax, annualInflation, startMonthOffset, initialGlobalTotalInvested, initialGlobalTotalJuros) {
      let currentGrossValue = initialGrossValue;
      let segmentTotalInvested = 0; // Aportes apenas neste segmento
      let valoresMensaisSegment = [];
      // O total investido e juros GLOBAIS precisam ser rastreados para o imposto
      let globalTotalInvested = initialGlobalTotalInvested;
      let globalTotalJuros = initialGlobalTotalJuros;

      // NÃ£o adiciona mÃªs 0 aqui, pois ele vem do segmento anterior ou Ã© o inicial global

      for (let i = 1; i <= duration; i++) {
        const currentGlobalMonth = startMonthOffset + i;

        const jurosDoMes = currentGrossValue * monthlyRate;
        globalTotalJuros += jurosDoMes;

        currentGrossValue += jurosDoMes + monthlyContribution;
        segmentTotalInvested += monthlyContribution;
        globalTotalInvested += monthlyContribution;

        // Imposto calculado sobre o ganho de capital GLOBAL (Juros Totais Globais)
        const impostoTotalGlobal = globalTotalJuros * tax;
        const valorLiquido = currentGrossValue - impostoTotalGlobal;

        valoresMensaisSegment.push({
          month: currentGlobalMonth,
          juros: jurosDoMes,
          totalInvestido: globalTotalInvested, // Mostrar o total global investido
          totalJuros: globalTotalJuros, // Mostrar o total global de juros
          imposto: impostoTotalGlobal, // Mostrar o imposto global
          valorLiquido: valorLiquido,
          totalAcumulado: currentGrossValue // Valor bruto acumulado
        });
      }

      const finalNetValue = valoresMensaisSegment.length > 0 ? valoresMensaisSegment[valoresMensaisSegment.length - 1].valorLiquido : initialGrossValue;

      return {
        finalGrossValue: currentGrossValue, // Valor bruto ao final do segmento
        finalNetValue: finalNetValue, // Valor lÃ­quido ao final do segmento
        finalGlobalTotalInvested: globalTotalInvested,
        finalGlobalTotalJuros: globalTotalJuros,
        valoresMensaisSegment: valoresMensaisSegment
      };
    }

    // FunÃ§Ã£o auxiliar para verificar se todos os objetivos sÃ£o atingidos em uma simulaÃ§Ã£o SEQUENCIAL
    function checkAllObjectivesMetSequential(objectives, fullSimulationData, annualInflation) {
        if (!objectives || objectives.length === 0 || !fullSimulationData || fullSimulationData.length === 0) return false;
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

        // Criar um mapa para acesso rÃ¡pido aos dados por mÃªs
        const simulationMap = new Map();
        fullSimulationData.forEach(data => simulationMap.set(data.month, data));

        for (const obj of objectives) {
            const targetMonth = obj.period;
            const monthData = simulationMap.get(targetMonth);

            if (!monthData) {
                // SimulaÃ§Ã£o nÃ£o cobriu o prazo deste objetivo
                // console.log(`SimulaÃ§Ã£o sequencial curta para ${obj.description} (Prazo: ${targetMonth})`);
                return false;
            }

            const inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, targetMonth);
            const netValueAtTargetMonth = monthData.valorLiquido;

            // console.log(`SEQ Check - Obj: ${obj.description}, MÃªs: ${targetMonth}, LÃ­quido: ${netValueAtTargetMonth}, Obj Corrigido: ${inflatedObjectiveValue}`);
            if (netValueAtTargetMonth < inflatedObjectiveValue) {
                // Este objetivo nÃ£o foi atingido no seu prazo
                return false;
            }
        }
        // Se chegou aqui, todos os objetivos foram atingidos em seus respectivos prazos na sequÃªncia
        return true;
    }

    // --- FunÃ§Ãµes de CÃ¡lculo Adicionais (Refatoradas para Sequencial) --- //

    // 1. Calcular Valor Inicial NecessÃ¡rio (sem aportes) - Retorna { value: number | Infinity, simulation: object | null }
    function calculateRequiredInitialValue(objectives, monthlyRate, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        // Ordenar objetivos por prazo
        const sortedObjectives = [...objectives].sort((a, b) => a.period - b.period);
        const maxPeriod = sortedObjectives[sortedObjectives.length - 1].period;
        if (maxPeriod <= 0) return { value: 0, simulation: null };

        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

        // FunÃ§Ã£o interna para rodar a simulaÃ§Ã£o sequencial completa com um dado valor inicial
        const runFullSequentialSimulation = (startValue) => {
            let fullSimulationData = [];
            let currentSegmentStartValue = startValue;
            let lastMonth = 0;
            let globalTotalInvested = startValue; // ComeÃ§a com o valor inicial
            let globalTotalJuros = 0;

            // Adicionar estado inicial (mÃªs 0)
            fullSimulationData.push({
                month: 0, juros: 0, totalInvestido: globalTotalInvested,
                totalJuros: 0, imposto: 0, valorLiquido: startValue,
                totalAcumulado: startValue
            });

            for (const obj of sortedObjectives) {
                const segmentDuration = obj.period - lastMonth;
                if (segmentDuration < 0) {
                    console.error("Erro na lÃ³gica de segmentos: duraÃ§Ã£o negativa.");
                    return null; // Erro na lÃ³gica
                }
                if (segmentDuration === 0) continue; // Pula se o prazo for o mesmo do anterior

                const segmentResult = calculateSegmentSimulation(
                    currentSegmentStartValue,
                    0, // Aporte zero nesta anÃ¡lise
                    monthlyRate,
                    segmentDuration,
                    tax,
                    annualInflation,
                    lastMonth,
                    globalTotalInvested,
                    globalTotalJuros
                );

                fullSimulationData = fullSimulationData.concat(segmentResult.valoresMensaisSegment);
                currentSegmentStartValue = segmentResult.finalNetValue; // PrÃ³ximo segmento comeÃ§a com o valor LÃQUIDO
                lastMonth = obj.period;
                globalTotalInvested = segmentResult.finalGlobalTotalInvested;
                globalTotalJuros = segmentResult.finalGlobalTotalJuros;
            }
            return fullSimulationData;
        };

        // --- LÃ³gica de Busca BinÃ¡ria --- //
        let low = 0;
        // Estimativa inicial alta: soma dos valores corrigidos dos objetivos
        let high = sortedObjectives.reduce((sum, obj) => sum + obj.value * Math.pow(1 + monthlyInflation, obj.period), 0) * 1.5;
        if (high < 100) high = 100; // MÃ­nimo para evitar problemas

        let requiredInitialValue = Infinity;
        let finalSimulationData = null;
        const maxIterations = 100;
        let iterations = 0;

        // Caso especial: taxa zero ou negativa (simplificado - pode precisar de ajuste fino)
        if (monthlyRate <= 0) {
            let maxRequired = 0;
            for (const obj of sortedObjectives) {
                 const inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, obj.period);
                 // Com taxa <= 0 e sem aportes, o valor sÃ³ diminui ou fica igual
                 // Precisa comeÃ§ar com o maior valor corrigido necessÃ¡rio
                 maxRequired = Math.max(maxRequired, inflatedObjectiveValue);
            }
            const simulation = runFullSequentialSimulation(maxRequired);
             if (simulation && checkAllObjectivesMetSequential(sortedObjectives, simulation, annualInflation)) {
                 return { value: maxRequired, simulation: { valoresMensais: simulation } };
             } else {
                 return { value: Infinity, simulation: null };
             }
        }

        while (iterations < maxIterations && (high - low) > 0.01) {
            const mid = low + (high - low) / 2;
            if (mid === low || mid === high) break;

            const currentSimData = runFullSequentialSimulation(mid);

            if (currentSimData && checkAllObjectivesMetSequential(sortedObjectives, currentSimData, annualInflation)) {
                requiredInitialValue = mid;
                finalSimulationData = currentSimData; // Guarda a simulaÃ§Ã£o que funcionou
                high = mid;
            } else {
                low = mid;
            }
            iterations++;
        }

        if (requiredInitialValue === Infinity) {
            // Tenta com o limite superior inicial como Ãºltimo recurso
            const highSimData = runFullSequentialSimulation(high);
             if (highSimData && checkAllObjectivesMetSequential(sortedObjectives, highSimData, annualInflation)) {
                 return { value: high, simulation: { valoresMensais: highSimData } };
             }
            return { value: Infinity, simulation: null };
        } else {
            const finalValue = requiredInitialValue < 0.01 ? 0 : requiredInitialValue;
            // Se o valor final for 0, recalcular a simulaÃ§Ã£o (ou usar a guardada se jÃ¡ for 0)
            if (finalValue === 0 && requiredInitialValue >= 0.01) {
                 finalSimulationData = runFullSequentialSimulation(0);
            }
            // Garante que a simulaÃ§Ã£o retornada Ã© a correta para o valor final
            if (!finalSimulationData || Math.abs(finalSimulationData[0].totalAcumulado - finalValue) > 0.01) {
                 finalSimulationData = runFullSequentialSimulation(finalValue);
            }
            return { value: finalValue, simulation: { valoresMensais: finalSimulationData } };
        }
    }

    // 2. Calcular Aporte Mensal Ideal Constante - Retorna { value: number | Infinity, simulation: object | null }
    function calculateIdealMonthlyContribution(objectives, initialSavings, monthlyRate, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        // Ordenar objetivos por prazo
        const sortedObjectives = [...objectives].sort((a, b) => a.period - b.period);
        const maxPeriod = sortedObjectives[sortedObjectives.length - 1].period;
        if (maxPeriod <= 0) return { value: 0, simulation: null };

        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

        // FunÃ§Ã£o interna para rodar a simulaÃ§Ã£o sequencial completa com um dado aporte
        const runFullSequentialSimulationWithContribution = (contribution) => {
            let fullSimulationData = [];
            let currentSegmentStartValue = initialSavings;
            let lastMonth = 0;
            let globalTotalInvested = initialSavings;
            let globalTotalJuros = 0;

            // Adicionar estado inicial (mÃªs 0)
            fullSimulationData.push({
                month: 0, juros: 0, totalInvestido: globalTotalInvested,
                totalJuros: 0, imposto: 0, valorLiquido: initialSavings,
                totalAcumulado: initialSavings
            });

            for (const obj of sortedObjectives) {
                const segmentDuration = obj.period - lastMonth;
                if (segmentDuration < 0) return null; // Erro
                if (segmentDuration === 0) continue;

                const segmentResult = calculateSegmentSimulation(
                    currentSegmentStartValue,
                    contribution, // Usar o aporte testado
                    monthlyRate,
                    segmentDuration,
                    tax,
                    annualInflation,
                    lastMonth,
                    globalTotalInvested,
                    globalTotalJuros
                );

                fullSimulationData = fullSimulationData.concat(segmentResult.valoresMensaisSegment);
                currentSegmentStartValue = segmentResult.finalNetValue;
                lastMonth = obj.period;
                globalTotalInvested = segmentResult.finalGlobalTotalInvested;
                globalTotalJuros = segmentResult.finalGlobalTotalJuros;
            }
            return fullSimulationData;
        };

        // --- LÃ³gica de Busca BinÃ¡ria --- //
        let low = 0;
        // Estimativa inicial alta (pode ser ajustada)
        let high = 100000; // Um valor alto inicial para o aporte
        let initialHighEstimateSim = runFullSequentialSimulationWithContribution(high);
        // Se a estimativa alta nÃ£o for suficiente, jÃ¡ retorna impossÃ­vel
        if (!initialHighEstimateSim || !checkAllObjectivesMetSequential(sortedObjectives, initialHighEstimateSim, annualInflation)) {
             // Tentar aumentar o high?
             high *= 5;
             initialHighEstimateSim = runFullSequentialSimulationWithContribution(high);
             if (!initialHighEstimateSim || !checkAllObjectivesMetSequential(sortedObjectives, initialHighEstimateSim, annualInflation)) {
                console.warn("NÃ£o foi possÃ­vel encontrar um aporte mensal suficiente mesmo com valor alto inicial.");
                return { value: Infinity, simulation: null };
             }
        }

        let idealContribution = Infinity;
        let finalSimulationData = null;
        const maxIterations = 100;
        let iterations = 0;

        // Caso base: verificar se jÃ¡ atinge com 0 aporte
        const zeroContributionSimData = runFullSequentialSimulationWithContribution(0);
        if (zeroContributionSimData && checkAllObjectivesMetSequential(sortedObjectives, zeroContributionSimData, annualInflation)) {
            return { value: 0, simulation: { valoresMensais: zeroContributionSimData } }; // Nenhum aporte necessÃ¡rio
        }

        while (iterations < maxIterations && (high - low) > 0.01) {
            const mid = low + (high - low) / 2;
            if (mid === low || mid === high) break;

            const currentSimData = runFullSequentialSimulationWithContribution(mid);

            if (currentSimData && checkAllObjectivesMetSequential(sortedObjectives, currentSimData, annualInflation)) {
                idealContribution = mid;
                finalSimulationData = currentSimData; // Guarda a simulaÃ§Ã£o que funcionou
                high = mid;
            } else {
                low = mid;
            }
            iterations++;
        }

        if (idealContribution === Infinity) {
            // Se a busca nÃ£o convergiu, mas o high inicial funcionou, retorna o high
            if (initialHighEstimateSim && checkAllObjectivesMetSequential(sortedObjectives, initialHighEstimateSim, annualInflation)) {
                 return { value: high, simulation: { valoresMensais: initialHighEstimateSim } };
            }
            console.warn("NÃ£o foi possÃ­vel encontrar um aporte mensal suficiente dentro dos limites/iteraÃ§Ãµes.");
            return { value: Infinity, simulation: null };
        } else {
            const finalValue = idealContribution < 0.01 ? 0 : idealContribution;
            // Se o valor final for 0, a simulaÃ§Ã£o correta Ã© a de aporte 0
            if (finalValue === 0 && idealContribution >= 0.01) {
                 finalSimulationData = zeroContributionSimData;
            }
             // Garante que a simulaÃ§Ã£o retornada Ã© a correta para o valor final
            if (!finalSimulationData || (finalSimulationData.length > 1 && Math.abs(finalSimulationData[1]?.totalInvestido - (initialSavings + finalValue)) > 0.01)) { // Verifica o aporte no primeiro mÃªs se houver mÃªs 1
                 finalSimulationData = runFullSequentialSimulationWithContribution(finalValue);
            }
            return { value: finalValue, simulation: { valoresMensais: finalSimulationData } };
        }
    }

    // 3. Calcular Tempo NecessÃ¡rio para Atingir Objetivos - Retorna { value: number | Infinity, simulation: object | null }
    function calculateRequiredTime(objectives, initialSavings, monthlyContribution, monthlyRate, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        // Ordenar objetivos por prazo
        const sortedObjectives = [...objectives].sort((a, b) => a.period - b.period);
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;
        const maxSimulationMonths = 1200; // Limite de 100 anos

        let fullSimulationData = [];
        let currentSegmentStartValue = initialSavings;
        let lastMonth = 0;
        let globalTotalInvested = initialSavings;
        let globalTotalJuros = 0;
        let finalMonth = Infinity;

        // Adicionar estado inicial (mÃªs 0)
        fullSimulationData.push({
            month: 0, juros: 0, totalInvestido: globalTotalInvested,
            totalJuros: 0, imposto: 0, valorLiquido: initialSavings,
            totalAcumulado: initialSavings
        });

        // Simular segmento por segmento atÃ© o prazo do Ãºltimo objetivo ORIGINAL
        const originalMaxPeriod = sortedObjectives[sortedObjectives.length - 1].period;
        let simulationReachedOriginalMaxPeriod = false;

        for (const obj of sortedObjectives) {
            const segmentDuration = obj.period - lastMonth;
            if (segmentDuration < 0) {
                console.error("Erro na lÃ³gica de segmentos: duraÃ§Ã£o negativa.");
                return { value: Infinity, simulation: { valoresMensais: fullSimulationData } }; // Retorna o que simulou atÃ© agora
            }
            if (segmentDuration === 0) continue;

            const segmentResult = calculateSegmentSimulation(
                currentSegmentStartValue,
                monthlyContribution,
                monthlyRate,
                segmentDuration,
                tax,
                annualInflation,
                lastMonth,
                globalTotalInvested,
                globalTotalJuros
            );

            fullSimulationData = fullSimulationData.concat(segmentResult.valoresMensaisSegment);
            currentSegmentStartValue = segmentResult.finalNetValue; // PrÃ³ximo segmento comeÃ§a com o valor LÃQUIDO
            lastMonth = obj.period;
            globalTotalInvested = segmentResult.finalGlobalTotalInvested;
            globalTotalJuros = segmentResult.finalGlobalTotalJuros;
        }
        simulationReachedOriginalMaxPeriod = true;

        // Verificar se todos os objetivos foram atingidos ATÃ o prazo do Ãºltimo
        if (checkAllObjectivesMetSequential(sortedObjectives, fullSimulationData, annualInflation)) {
            // Encontrar o mÃªs exato em que o ÃLTIMO objetivo foi atingido
            const lastObjective = sortedObjectives[sortedObjectives.length - 1];
            let monthLastMet = Infinity;

            // Procurar a partir do mÃªs 1 atÃ© o prazo do Ãºltimo objetivo
            for (let m = 1; m <= lastObjective.period; m++) {
                 const monthData = fullSimulationData.find(d => d.month === m);
                 if (monthData) {
                     // Verificar se TODOS os objetivos com prazo <= m foram atingidos neste mÃªs
                     const objectivesDueByMonthM = sortedObjectives.filter(o => o.period <= m);
                     if (checkAllObjectivesMetSequential(objectivesDueByMonthM, fullSimulationData.slice(0, m + 1), annualInflation)) {
                         // Se este Ã© o Ãºltimo objetivo, encontramos o mÃªs
                         if (objectivesDueByMonthM.length === sortedObjectives.length) {
                            monthLastMet = m;
                            break; // Encontrou o primeiro mÃªs onde o Ãºltimo (e todos anteriores) foi atingido
                         }
                     }
                 }
            }

             // Se encontrou o mÃªs, retorna
             if (monthLastMet !== Infinity) {
                 return { value: monthLastMet, simulation: { valoresMensais: fullSimulationData.slice(0, monthLastMet + 1) } };
             }
             // Se checkAllObjectivesMetSequential deu true, mas nÃ£o achou o mÃªs exato (estranho), retorna o prazo do Ãºltimo
             console.warn("InconsistÃªncia ao encontrar mÃªs exato de conclusÃ£o do Ãºltimo objetivo, retornando prazo final original.");
             return { value: originalMaxPeriod, simulation: { valoresMensais: fullSimulationData } };
        }

        // Se nÃ£o atingiu todos atÃ© o prazo final original, continuar simulando mÃªs a mÃªs
        let currentMonth = lastMonth;
        let currentGrossValue = fullSimulationData.length > 0 ? fullSimulationData[fullSimulationData.length - 1].totalAcumulado : initialSavings; // Continuar do Ãºltimo valor bruto

        while (currentMonth < maxSimulationMonths) {
            currentMonth++;

            const jurosDoMes = currentGrossValue * monthlyRate;
            globalTotalJuros += jurosDoMes;
            currentGrossValue += jurosDoMes + monthlyContribution;
            globalTotalInvested += monthlyContribution;

            const impostoTotalGlobal = globalTotalJuros * tax;
            const valorLiquido = currentGrossValue - impostoTotalGlobal;

            fullSimulationData.push({
                month: currentMonth,
                juros: jurosDoMes,
                totalInvestido: globalTotalInvested,
                totalJuros: globalTotalJuros,
                imposto: impostoTotalGlobal,
                valorLiquido: valorLiquido,
                totalAcumulado: currentGrossValue
            });

            // Verificar se TODOS os objetivos foram atingidos neste mÃªs
            if (checkAllObjectivesMetSequential(sortedObjectives, fullSimulationData, annualInflation)) {
                finalMonth = currentMonth;
                break; // Todos atingidos!
            }
        }

        if (finalMonth === Infinity) {
            // NÃ£o atingiu dentro do limite
            return { value: Infinity, simulation: { valoresMensais: fullSimulationData } };
        } else {
            // Atingiu apÃ³s o prazo original do Ãºltimo
            return { value: finalMonth, simulation: { valoresMensais: fullSimulationData.slice(0, finalMonth + 1) } };
        }
    }

    // 4. Calcular Rentabilidade Anual Ideal Constante - Retorna { value: number | Infinity, simulation: object | null }
    function calculateIdealAnnualRate(objectives, initialSavings, monthlyContribution, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        // Ordenar objetivos por prazo
        const sortedObjectives = [...objectives].sort((a, b) => a.period - b.period);
        const maxPeriod = sortedObjectives[sortedObjectives.length - 1].period;
        if (maxPeriod <= 0) return { value: 0, simulation: null };

        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

        // FunÃ§Ã£o interna para rodar a simulaÃ§Ã£o sequencial completa com uma dada taxa mensal
        const runFullSequentialSimulationWithRate = (rate) => {
            let fullSimulationData = [];
            let currentSegmentStartValue = initialSavings;
            let lastMonth = 0;
            let globalTotalInvested = initialSavings;
            let globalTotalJuros = 0;

            // Adicionar estado inicial (mÃªs 0)
            fullSimulationData.push({
                month: 0, juros: 0, totalInvestido: globalTotalInvested,
                totalJuros: 0, imposto: 0, valorLiquido: initialSavings,
                totalAcumulado: initialSavings
            });

            for (const obj of sortedObjectives) {
                const segmentDuration = obj.period - lastMonth;
                if (segmentDuration < 0) return null; // Erro
                if (segmentDuration === 0) continue;

                const segmentResult = calculateSegmentSimulation(
                    currentSegmentStartValue,
                    monthlyContribution,
                    rate, // Usar a taxa testada
                    segmentDuration,
                    tax,
                    annualInflation,
                    lastMonth,
                    globalTotalInvested,
                    globalTotalJuros
                );

                fullSimulationData = fullSimulationData.concat(segmentResult.valoresMensaisSegment);
                currentSegmentStartValue = segmentResult.finalNetValue;
                lastMonth = obj.period;
                globalTotalInvested = segmentResult.finalGlobalTotalInvested;
                globalTotalJuros = segmentResult.finalGlobalTotalJuros;
            }
            return fullSimulationData;
        };

        // --- LÃ³gica de Busca BinÃ¡ria --- //
        let lowMonthlyRate = -0.05; // Permitir taxas negativas pequenas
        let highMonthlyRate = 1.0; // 100% ao mÃªs (limite alto)
        let idealMonthlyRate = Infinity; // ComeÃ§a com infinito
        let finalSimulationData = null;
        const maxIterations = 100;
        let iterations = 0;

        // Caso base: verificar se jÃ¡ atinge com taxa mÃ­nima
        const lowRateSimData = runFullSequentialSimulationWithRate(lowMonthlyRate);
        if (lowRateSimData && checkAllObjectivesMetSequential(sortedObjectives, lowRateSimData, annualInflation)) {
             const lowAnnualRate = Math.pow(1 + lowMonthlyRate, 12) - 1;
             return { value: Math.max(0, lowAnnualRate), simulation: { valoresMensais: lowRateSimData } };
        }

        // Verificar se a taxa mÃ¡xima funciona (se nÃ£o, Ã© impossÃ­vel)
        const highRateSimData = runFullSequentialSimulationWithRate(highMonthlyRate);
        if (!highRateSimData || !checkAllObjectivesMetSequential(sortedObjectives, highRateSimData, annualInflation)) {
            console.warn("NÃ£o foi possÃ­vel encontrar uma taxa de rentabilidade suficiente mesmo com o limite superior.");
            return { value: Infinity, simulation: null };
        }

        while (iterations < maxIterations && (highMonthlyRate - lowMonthlyRate) > 1e-7) {
            const midMonthlyRate = lowMonthlyRate + (highMonthlyRate - lowMonthlyRate) / 2;
            if (midMonthlyRate === lowMonthlyRate || midMonthlyRate === highMonthlyRate) break;

            const currentSimData = runFullSequentialSimulationWithRate(midMonthlyRate);

            if (currentSimData && checkAllObjectivesMetSequential(sortedObjectives, currentSimData, annualInflation)) {
                idealMonthlyRate = midMonthlyRate;
                finalSimulationData = currentSimData; // Guarda a simulaÃ§Ã£o que funcionou
                highMonthlyRate = midMonthlyRate;
            } else {
                lowMonthlyRate = midMonthlyRate;
            }
            iterations++;
        }

        if (idealMonthlyRate !== Infinity) {
            const idealAnnualRate = Math.pow(1 + idealMonthlyRate, 12) - 1;
            const finalValue = idealAnnualRate < 1e-6 ? 0 : idealAnnualRate;
            // Se a taxa final for 0, recalcular a simulaÃ§Ã£o com taxa 0
            if (finalValue === 0 && idealAnnualRate >= 1e-6) {
                 finalSimulationData = runFullSequentialSimulationWithRate(0);
            }
            // Garante que a simulaÃ§Ã£o retornada Ã© a correta para o valor final
             if (!finalSimulationData) { // Se nÃ£o guardou nenhuma simulaÃ§Ã£o vÃ¡lida
                 finalSimulationData = runFullSequentialSimulationWithRate(idealMonthlyRate);
             }
            return { value: finalValue, simulation: { valoresMensais: finalSimulationData } };
        } else {
            // Se a busca nÃ£o convergiu, mas a taxa alta funcionou, retorna a taxa alta
            // (JÃ¡ verificamos que highRateSimData funciona no inÃ­cio)
            console.warn("Busca pela taxa ideal nÃ£o convergiu, retornando limite superior funcional.");
            return { value: Math.pow(1 + highMonthlyRate, 12) - 1, simulation: { valoresMensais: highRateSimData } };
        }
    }

    // --- FunÃ§Ã£o Principal de CÃ¡lculo (Refatorada para Sequencial) ---
    function calculateSavings() {
      // Validar se hÃ¡ objetivos
      if (objectives.length === 0) {
        alert("Por favor, adicione pelo menos um objetivo financeiro.");
        return;
      }

      // --- Obter Entradas --- //
      const initialSavings = parseCurrency(document.getElementById('initialSavings').value) || 0;
      const monthlyContribution = parseCurrency(document.getElementById('monthlyContribution').value) || 0;
      let interestRate = parseFloat(document.getElementById('interestRate').value.replace(',', '.')) || 0;
      const interestRateType = document.getElementById('interestRateType').value;
      let taxRate = parseFloat(document.getElementById('taxRate').value.replace(',', '.')) || 0;
      let annualInflation = parseFloat(document.getElementById('annualInflation').value.replace(',', '.')) || 0;

      // Validar entradas numÃ©ricas
      if (isNaN(initialSavings) || isNaN(monthlyContribution) || isNaN(interestRate) || isNaN(taxRate) || isNaN(annualInflation)) {
        alert("Por favor, verifique se todos os valores numÃ©ricos (valores, taxas) estÃ£o preenchidos corretamente.");
        return;
      }

      // Converter taxas para decimal
      taxRate = taxRate / 100;
      annualInflation = annualInflation / 100;
      let monthlyRate = 0;
      if (interestRateType === 'anual') {
        monthlyRate = Math.pow(1 + (interestRate / 100), 1/12) - 1;
      } else { // Mensal
        monthlyRate = interestRate / 100;
      }

      // Ordenar objetivos por prazo
      const sortedObjectives = [...objectives].sort((a, b) => a.period - b.period);
      const maxPeriod = sortedObjectives.length > 0 ? sortedObjectives[sortedObjectives.length - 1].period : 0;
      if (maxPeriod <= 0 && sortedObjectives.length > 0) {
          alert("Prazo invÃ¡lido. Verifique os prazos dos objetivos (devem ser maiores que 0).");
          return;
      }

      // --- SimulaÃ§Ã£o Principal Sequencial ---
      console.time("Main Sequential Simulation");
      let fullSimulationData = [];
      let currentSegmentStartValue = initialSavings;
      let lastMonth = 0;
      let globalTotalInvested = initialSavings;
      let globalTotalJuros = 0;
      let objectiveResults = []; // Para armazenar o status de cada objetivo
      const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

      // Adicionar estado inicial (mÃªs 0)
      fullSimulationData.push({
          month: 0, juros: 0, totalInvestido: globalTotalInvested,
          totalJuros: 0, imposto: 0, valorLiquido: initialSavings,
          totalAcumulado: initialSavings
      });

      for (const obj of sortedObjectives) {
          const segmentDuration = obj.period - lastMonth;
          if (segmentDuration < 0) {
              console.error("Erro na lÃ³gica de segmentos: duraÃ§Ã£o negativa.");
              alert("Erro interno no cÃ¡lculo sequencial. Verifique os prazos dos objetivos (nÃ£o podem diminuir).");
              return;
          }

          let segmentResult = null;
          if (segmentDuration > 0) {
              segmentResult = calculateSegmentSimulation(
                  currentSegmentStartValue,
                  monthlyContribution,
                  monthlyRate,
                  segmentDuration,
                  taxRate,
                  annualInflation,
                  lastMonth,
                  globalTotalInvested,
                  globalTotalJuros
              );
              fullSimulationData = fullSimulationData.concat(segmentResult.valoresMensaisSegment);
              currentSegmentStartValue = segmentResult.finalNetValue; // PrÃ³ximo segmento comeÃ§a com o valor LÃQUIDO
              globalTotalInvested = segmentResult.finalGlobalTotalInvested;
              globalTotalJuros = segmentResult.finalGlobalTotalJuros;
          }
          // Se duration for 0, nÃ£o calcula, mas ainda verifica o objetivo no ponto atual

          // Verificar status deste objetivo ao final do seu prazo (segmento)
          const monthDataAtDeadline = fullSimulationData.find(d => d.month === obj.period);
          if (monthDataAtDeadline) {
              const inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, obj.period);
              const netValueAtDeadline = monthDataAtDeadline.valorLiquido;
              objectiveResults.push({
                  description: obj.description,
                  period: obj.period,
                  targetValue: inflatedObjectiveValue,
                  achievedValue: netValueAtDeadline,
                  met: netValueAtDeadline >= inflatedObjectiveValue
              });
          } else {
              // Isso nÃ£o deveria acontecer se a simulaÃ§Ã£o foi feita corretamente
              console.error(`Dados nÃ£o encontrados para o mÃªs ${obj.period} do objetivo ${obj.description}`);
              objectiveResults.push({
                  description: obj.description,
                  period: obj.period,
                  targetValue: obj.value * Math.pow(1 + monthlyInflation, obj.period),
                  achievedValue: null,
                  met: false
              });
          }

          lastMonth = obj.period;
      }
      console.timeEnd("Main Sequential Simulation");

      // --- Calcular AnÃ¡lises Adicionais (jÃ¡ refatoradas para sequencial) ---
      console.time("Additional Calculations");
      const requiredInitial = calculateRequiredInitialValue(sortedObjectives, monthlyRate, taxRate, annualInflation);
      const idealContribution = calculateIdealMonthlyContribution(sortedObjectives, initialSavings, monthlyRate, taxRate, annualInflation);
      const requiredTime = calculateRequiredTime(sortedObjectives, initialSavings, monthlyContribution, monthlyRate, taxRate, annualInflation);
      const idealRate = calculateIdealAnnualRate(sortedObjectives, initialSavings, monthlyContribution, taxRate, annualInflation);
      console.timeEnd("Additional Calculations");

      // --- Guardar Dados do CÃ¡lculo Atual ---
      currentCalculationData = {
        params: { initialSavings, monthlyContribution, interestRate, interestRateType, taxRate, annualInflation, objectives: sortedObjectives },
        results: {
          mainSimulation: { valoresMensais: fullSimulationData },
          objectiveResults: objectiveResults,
          requiredInitialValue: requiredInitial,
          idealContribution: idealContribution,
          requiredTime: requiredTime,
          idealRate: idealRate
        }
      };

      // --- Exibir Resultados ---
      displayResults(currentCalculationData);

      // Habilitar botÃµes de cenÃ¡rio e WhatsApp
      document.getElementById('resultsContainer').style.display = 'block';
      document.getElementById('saveScenarioButton').disabled = false;
      document.getElementById('whatsappButton').style.display = 'block';
      document.getElementById('analyzeScenarioButton').disabled = scenarios.length < 2;
    }

    // --- FunÃ§Ãµes de ExibiÃ§Ã£o de Resultados (Refatoradas para Sequencial) ---
    function displayResults(data) {
        const summaryDiv = document.getElementById('resultSummary');
        let summaryHTML = '<h4>Resultados da SimulaÃ§Ã£o Principal:</h4>';
        let allMet = true;
        let recommendationDetails = [];

        data.results.objectiveResults.forEach(objResult => {
            if (objResult.met) {
                summaryHTML += `<p><strong>${objResult.description} (Prazo: ${objResult.period}m):</strong> <span style="color: green;">Atingido!</span> (Valor LÃ­quido: ${formatCurrencyValue(objResult.achievedValue)} vs Meta Corrigida: ${formatCurrencyValue(objResult.targetValue)})</p>`;
            } else {
                allMet = false;
                const shortfall = objResult.targetValue - (objResult.achievedValue || 0);
                summaryHTML += `<p><strong>${objResult.description} (Prazo: ${objResult.period}m):</strong> <span style="color: red;">NÃ£o Atingido</span> (Valor LÃ­quido: ${formatCurrencyValue(objResult.achievedValue)} vs Meta Corrigida: ${formatCurrencyValue(objResult.targetValue)}, Faltou: ${formatCurrencyValue(shortfall)})</p>`;
                recommendationDetails.push(`- ${objResult.description}: Faltou ${formatCurrencyValue(shortfall)} no prazo de ${objResult.period} meses.`);
            }
        });
        summaryDiv.innerHTML = summaryHTML;

        // Exibir GrÃ¡fico/Tabela Principal
        drawProjectionChart('projectionChart', data.results.mainSimulation.valoresMensais, data.params.objectives, data.params.annualInflation);
        fillDataTable('tableProjection', data.results.mainSimulation.valoresMensais, data.params.objectives, data.params.annualInflation);
        showChart('projectionChart'); // Mostrar grÃ¡fico por padrÃ£o

        // Exibir AnÃ¡lises Adicionais
        displayAnalysisResult('InitialValue', data.results.requiredInitialValue, data.params.objectives, data.params.annualInflation);
        displayAnalysisResult('Contribution', data.results.idealContribution, data.params.objectives, data.params.annualInflation);
        displayAnalysisResult('Time', data.results.requiredTime, data.params.objectives, data.params.annualInflation);
        displayAnalysisResult('Rate', data.results.idealRate, data.params.objectives, data.params.annualInflation);

        // Gerar RecomendaÃ§Ã£o
        generateRecommendation(allMet, recommendationDetails, data.results.idealContribution, data.results.idealRate, data.results.requiredTime);

        // Preparar botÃ£o WhatsApp
        setupWhatsAppButton(data);
    }

    function displayAnalysisResult(type, analysisData, objectives, annualInflation) {
        const container = document.getElementById(`analysis${type}Container`);
        const valueSpan = document.getElementById(`analysis${type}Value`);
        const chartCanvasId = `chart${type}`;
        const tableId = `table${type}`;

        if (!container || !valueSpan) return;

        let formattedValue = "N/A";
        if (analysisData.value === Infinity) {
            formattedValue = "ImpossÃ­vel atingir";
        } else if (type === 'InitialValue' || type === 'Contribution') {
            formattedValue = formatCurrencyValue(analysisData.value);
        } else if (type === 'Time') {
            formattedValue = `${analysisData.value} meses`;
        } else if (type === 'Rate') {
            formattedValue = formatPercentageValue(analysisData.value);
        }
        valueSpan.textContent = formattedValue;

        if (analysisData.simulation && analysisData.simulation.valoresMensais) {
            container.style.display = 'block';
            drawProjectionChart(chartCanvasId, analysisData.simulation.valoresMensais, objectives, annualInflation);
            fillDataTable(tableId, analysisData.simulation.valoresMensais, objectives, annualInflation);
            showChart(chartCanvasId); // Mostrar grÃ¡fico por padrÃ£o
        } else {
            // Esconder grÃ¡fico/tabela se nÃ£o houver simulaÃ§Ã£o (ex: impossÃ­vel)
            container.style.display = 'block'; // Manter a seÃ§Ã£o visÃ­vel para mostrar o valor "ImpossÃ­vel"
            const chartSlide = document.getElementById(`${chartCanvasId}Slide`);
            const tableSlide = document.getElementById(`${tableId}Slide`);
            if(chartSlide) chartSlide.style.display = 'none';
            if(tableSlide) tableSlide.style.display = 'none';
            // Ocultar botÃµes de navegaÃ§Ã£o tambÃ©m
            const navButtons = container.querySelectorAll('.chart-nav button');
            navButtons.forEach(btn => btn.style.display = 'none');
        }
    }

    // --- FunÃ§Ãµes de GrÃ¡ficos e Tabelas (Refatoradas para Sequencial) ---
    function drawProjectionChart(canvasId, valoresMensais, objectives, annualInflation) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        if (chartInstances[canvasId]) {
            chartInstances[canvasId].destroy();
        }

        if (!valoresMensais || valoresMensais.length === 0) return;

        const labels = valoresMensais.map(v => v.month);
        const totalAcumuladoData = valoresMensais.map(v => v.totalAcumulado);
        const valorLiquidoData = valoresMensais.map(v => v.valorLiquido);
        const totalInvestidoData = valoresMensais.map(v => v.totalInvestido);
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

        // Preparar dados dos objetivos corrigidos pela inflaÃ§Ã£o
        const objectiveDatasets = objectives.map((obj, index) => {
            const color = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'][index % 6]; // Ciclo de cores
            const data = valoresMensais.map(v => {
                if (v.month >= obj.period) {
                    // Mostrar o valor corrigido apenas atÃ© o prazo
                    return obj.value * Math.pow(1 + monthlyInflation, obj.period);
                } else {
                    return obj.value * Math.pow(1 + monthlyInflation, v.month);
                }
            });
            // Ajuste para mostrar linha completa atÃ© o prazo
            const objectiveLineData = valoresMensais.map(v => v.month <= obj.period ? obj.value * Math.pow(1 + monthlyInflation, v.month) : null);

            return {
                label: `Meta: ${obj.description} (Corrigido)`, // Nome do objetivo
                data: objectiveLineData,
                borderColor: color,
                borderDash: [5, 5], // Linha tracejada
                fill: false,
                pointRadius: 0, // Sem pontos
                tension: 0.1
            };
        });

        // Annotations para marcar prazos dos objetivos
        const annotations = objectives.reduce((acc, obj) => {
            acc[`line-${obj.period}`] = {
                type: 'line',
                xMin: obj.period,
                xMax: obj.period,
                borderColor: 'rgba(150, 150, 150, 0.5)', // Cinza translÃºcido
                borderWidth: 1,
                borderDash: [2, 2],
                label: {
                    content: `${obj.description} (${obj.period}m)`,
                    enabled: true,
                    position: 'start',
                    backgroundColor: 'rgba(200, 200, 200, 0.7)',
                    color: 'black',
                    font: { size: 9 },
                    yAdjust: -10
                }
            };
            return acc;
        }, {});

        chartInstances[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Valor LÃ­quido',
                        data: valorLiquidoData,
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Valor Bruto Acumulado',
                        data: totalAcumuladoData,
                        borderColor: 'rgb(255, 159, 64)',
                        fill: false,
                        tension: 0.1
                    },
                    {
                        label: 'Total Investido',
                        data: totalInvestidoData,
                        borderColor: 'rgb(54, 162, 235)',
                        fill: false,
                        tension: 0.1
                    },
                    ...objectiveDatasets // Adicionar datasets dos objetivos
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Meses'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Valor (R$)'
                        },
                        ticks: {
                            callback: function(value, index, values) {
                                return formatCurrencyValue(value);
                            }
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += formatCurrencyValue(context.parsed.y);
                                }
                                return label;
                            }
                        }
                    },
                    annotation: {
                        annotations: annotations
                    }
                }
            }
        });
    }

    function fillDataTable(tableId, valoresMensais, objectives, annualInflation) {
        const table = document.getElementById(tableId);
        if (!table) return;
        table.innerHTML = ''; // Limpar tabela

        if (!valoresMensais || valoresMensais.length === 0) return;

        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;
        const objectiveDeadlines = new Set(objectives.map(o => o.period));

        // CabeÃ§alho
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const headers = ['MÃªs', 'Juros (MÃªs)', 'Total Investido', 'Total Juros (Acum.)', 'Imposto (Acum.)', 'Valor LÃ­quido', 'Valor Bruto (Acum.)'];
        // Adicionar colunas para objetivos corrigidos
        objectives.forEach(obj => headers.push(`Meta: ${obj.description} (Corrigido)`));
        headers.forEach(text => {
            const th = document.createElement('th');
            th.textContent = text;
            headerRow.appendChild(th);
        });

        // Corpo
        const tbody = table.createTBody();
        valoresMensais.forEach(data => {
            const row = tbody.insertRow();
            if (objectiveDeadlines.has(data.month)) {
                row.classList.add('objective-deadline-row'); // Destacar linha do prazo
            }
            const cells = [
                data.month,
                formatCurrencyValue(data.juros),
                formatCurrencyValue(data.totalInvestido),
                formatCurrencyValue(data.totalJuros),
                formatCurrencyValue(data.imposto),
                formatCurrencyValue(data.valorLiquido),
                formatCurrencyValue(data.totalAcumulado)
            ];
            // Adicionar valores dos objetivos corrigidos
            objectives.forEach(obj => {
                const inflatedValue = obj.value * Math.pow(1 + monthlyInflation, data.month);
                cells.push(formatCurrencyValue(inflatedValue));
            });

            cells.forEach(value => {
                const cell = row.insertCell();
                cell.textContent = value;
            });
        });
    }

    function showChart(chartIdBase) {
        document.getElementById(`chart${chartIdBase}Slide`).style.display = 'block';
        document.getElementById(`table${chartIdBase}Slide`).style.display = 'none';
    }

    function showTable(tableIdBase) {
        document.getElementById(`chart${tableIdBase}Slide`).style.display = 'none';
        document.getElementById(`table${tableIdBase}Slide`).style.display = 'block';
    }

    // --- FunÃ§Ãµes de RecomendaÃ§Ã£o e WhatsApp (Ajustadas) ---
    function generateRecommendation(allMet, details, idealContribution, idealRate, requiredTime) {
        const recommendationDiv = document.getElementById('recommendationDiv');
        const recommendationText = document.getElementById('recommendationText');
        let text = '';

        if (allMet) {
            text = 'ParabÃ©ns! Com os parÃ¢metros atuais, vocÃª estÃ¡ no caminho certo para atingir todos os seus objetivos sequencialmente nos prazos definidos.';
        } else {
            text = 'AtenÃ§Ã£o! Com os parÃ¢metros atuais, alguns objetivos nÃ£o serÃ£o atingidos nos prazos definidos na sequÃªncia:';
            details.forEach(detail => text += `<br>${detail}`);
            text += '<br><br><strong>SugestÃµes:</strong>';

            if (idealContribution.value !== Infinity && idealContribution.value > (currentCalculationData?.params?.monthlyContribution || 0)) {
                text += `<br>- Considere aumentar seu aporte mensal para aproximadamente ${formatCurrencyValue(idealContribution.value)}.`;
            }
            if (idealRate.value !== Infinity && idealRate.value > (Math.pow(1 + (currentCalculationData?.params?.monthlyRate || 0), 12) - 1)) {
                text += `<br>- Busque investimentos com rentabilidade anual prÃ³xima a ${formatPercentageValue(idealRate.value)}.`;
            }
            if (requiredTime.value !== Infinity && requiredTime.value > (currentCalculationData?.params?.objectives[currentCalculationData.params.objectives.length - 1]?.period || 0)) {
                text += `<br>- Se mantiver os parÃ¢metros, o tempo total necessÃ¡rio serÃ¡ de aproximadamente ${requiredTime.value} meses.`;
            }
             text += '<br>- Avalie ajustar os valores ou prazos dos seus objetivos.';
        }

        recommendationText.innerHTML = text;
        recommendationDiv.style.display = 'block';
    }

    function setupWhatsAppButton(data) {
        const button = document.getElementById('whatsappButton');
        if (!data || !data.params || !data.results) {
            button.style.display = 'none';
            return;
        }

        let message = `*Resumo da SimulaÃ§Ã£o Sequencial de Objetivos*

`;
        message += `*ParÃ¢metros:*
`;
        message += `- Valor Inicial: ${formatCurrencyValue(data.params.initialSavings)}
`;
        message += `- Aporte Mensal: ${formatCurrencyValue(data.params.monthlyContribution)}
`;
        const rateDisplay = data.params.interestRateType === 'anual' ? `${(data.params.interestRate).toFixed(2).replace('.',',')}% a.a.` : `${(data.params.interestRate).toFixed(2).replace('.',',')}% a.m.`;
        message += `- Taxa Juros: ${rateDisplay}
`;
        message += `- IR: ${formatPercentageValue(data.params.taxRate)}
`;
        message += `- InflaÃ§Ã£o: ${formatPercentageValue(data.params.annualInflation)}

`;
        message += `*Objetivos Adicionados (${data.params.objectives.length}):*
`;
        data.params.objectives.forEach(obj => {
            message += `- ${obj.description}: ${formatCurrencyValue(obj.value)} em ${obj.period} meses
`;
        });
        message += `
*Resultados da SimulaÃ§Ã£o Principal:*
`;
        let allMet = true;
        data.results.objectiveResults.forEach(res => {
            if (res.met) {
                message += `- ${res.description}: Atingido! (Prazo ${res.period}m)
`;
            } else {
                allMet = false;
                message += `- ${res.description}: NÃO Atingido (Prazo ${res.period}m)
`;
            }
        });
        message += `
*AnÃ¡lises Adicionais:*
`;
        message += `- Valor Inicial Ideal (s/ aporte): ${data.results.requiredInitialValue.value === Infinity ? 'ImpossÃ­vel' : formatCurrencyValue(data.results.requiredInitialValue.value)}
`;
        message += `- Aporte Mensal Ideal: ${data.results.idealContribution.value === Infinity ? 'ImpossÃ­vel' : formatCurrencyValue(data.results.idealContribution.value)}
`;
        message += `- Tempo NecessÃ¡rio: ${data.results.requiredTime.value === Infinity ? '> 100 anos' : `${data.results.requiredTime.value} meses`}
`;
        message += `- Rentabilidade Anual Ideal: ${data.results.idealRate.value === Infinity ? 'ImpossÃ­vel' : formatPercentageValue(data.results.idealRate.value)}
`;

        const encodedMessage = encodeURIComponent(message);
        button.href = `https://wa.me/?text=${encodedMessage}`;
        button.style.display = 'block';
    }

    // --- FunÃ§Ãµes de Gerenciamento de CenÃ¡rios (Adaptadas) ---
    function addCurrentScenario() {
        if (!currentCalculationData) {
            alert("Calcule uma projeÃ§Ã£o antes de salvar o cenÃ¡rio.");
            return;
        }

        const scenarioName = prompt("Digite um nome para este cenÃ¡rio:", `CenÃ¡rio ${scenarios.length + 1}`);
        if (!scenarioName) return; // Cancelado pelo usuÃ¡rio

        // Criar uma cÃ³pia profunda dos dados para evitar alteraÃ§Ãµes acidentais
        const scenarioData = JSON.parse(JSON.stringify(currentCalculationData));

        scenarios.push({ name: scenarioName, data: scenarioData });
        renderSavedScenarios();
        document.getElementById('analyzeScenarioButton').disabled = scenarios.length < 2;
    }

    function renderSavedScenarios() {
        const listDiv = document.getElementById('savedScenariosList');
        const container = document.getElementById('scenariosContainer');
        if (scenarios.length === 0) {
            listDiv.innerHTML = 'Nenhum cenÃ¡rio salvo ainda.';
            container.style.display = 'none';
            return;
        }

        container.style.display = 'block';
        listDiv.innerHTML = '';
        scenarios.forEach((scenario, index) => {
            const card = document.createElement('div');
            card.className = 'scenario-card';
            card.id = `scenario-${index}`;
            card.innerHTML = `
                <div class="scenario-header">
                    <h5 class="scenario-title">${scenario.name}</h5>
                    <div class="scenario-actions">
                        <input type="checkbox" id="compare-${index}" name="compareScenario" value="${index}" style="width: auto; margin-top: 0;">
                        <label for="compare-${index}" style="margin: 0 5px 0 0; font-weight: normal;">Comparar</label>
                        <button class="scenario-select" onclick="selectScenario(${index})">Ver</button>
                        <button class="scenario-delete" onclick="deleteScenario(${index})">Excluir</button>
                    </div>
                </div>
                <div class="scenario-content">
                    <div class="scenario-info">
                        <p><strong>Valor Inicial:</strong> ${formatCurrencyValue(scenario.data.params.initialSavings)}</p>
                        <p><strong>Aporte Mensal:</strong> ${formatCurrencyValue(scenario.data.params.monthlyContribution)}</p>
                        <p><strong>Taxa:</strong> ${scenario.data.params.interestRate.toFixed(2).replace('.',',')}% ${scenario.data.params.interestRateType === 'anual' ? 'a.a.' : 'a.m.'}</p>
                    </div>
                    <div class="scenario-info">
                        <p><strong>IR:</strong> ${formatPercentageValue(scenario.data.params.taxRate)}</p>
                        <p><strong>InflaÃ§Ã£o:</strong> ${formatPercentageValue(scenario.data.params.annualInflation)}</p>
                    </div>
                </div>
                <div class="scenario-details">
                    <strong>Objetivos (${scenario.data.params.objectives.length}):</strong>
                    <ul>
                        ${scenario.data.params.objectives.map(obj => `<li>- ${obj.description} (${formatCurrencyValue(obj.value)} em ${obj.period}m)</li>`).join('')}
                    </ul>
                </div>
            `;
            listDiv.appendChild(card);
        });
    }

    function deleteScenario(index) {
        if (confirm(`Tem certeza que deseja excluir o cenÃ¡rio "${scenarios[index].name}"?`)) {
            scenarios.splice(index, 1);
            renderSavedScenarios();
            document.getElementById('analyzeScenarioButton').disabled = scenarios.length < 2;
            // Se o cenÃ¡rio excluÃ­do estava sendo exibido, limpar a exibiÃ§Ã£o
            if (currentCalculationData && currentCalculationData.scenarioIndex === index) {
                document.getElementById('resultsContainer').style.display = 'none';
                currentCalculationData = null;
            }
        }
    }

    function selectScenario(index) {
        if (index < 0 || index >= scenarios.length) return;
        currentCalculationData = JSON.parse(JSON.stringify(scenarios[index].data)); // Carregar cÃ³pia
        currentCalculationData.scenarioIndex = index; // Marcar qual cenÃ¡rio estÃ¡ ativo

        // Marcar card como ativo
        document.querySelectorAll('.scenario-card').forEach(card => card.classList.remove('active'));
        document.getElementById(`scenario-${index}`).classList.add('active');

        // Preencher formulÃ¡rio (opcional, mas Ãºtil para ediÃ§Ã£o)
        document.getElementById('initialSavings').value = formatCurrencyValue(currentCalculationData.params.initialSavings);
        document.getElementById('monthlyContribution').value = formatCurrencyValue(currentCalculationData.params.monthlyContribution);
        document.getElementById('interestRate').value = (currentCalculationData.params.interestRate).toFixed(2).replace('.',',');
        document.getElementById('interestRateType').value = currentCalculationData.params.interestRateType;
        document.getElementById('taxRate').value = (currentCalculationData.params.taxRate * 100).toFixed(2).replace('.',',');
        document.getElementById('annualInflation').value = (currentCalculationData.params.annualInflation * 100).toFixed(2).replace('.',',');
        objectives = [...currentCalculationData.params.objectives]; // Carregar objetivos
        renderObjectivesList();

        // Exibir resultados do cenÃ¡rio selecionado
        displayResults(currentCalculationData);
        document.getElementById('resultsContainer').style.display = 'block';
        document.getElementById('whatsappButton').style.display = 'block'; // Habilitar WhatsApp para cenÃ¡rio carregado
    }

    function startNewScenario() {
        // Limpar seleÃ§Ã£o de cenÃ¡rio
        document.querySelectorAll('.scenario-card').forEach(card => card.classList.remove('active'));
        currentCalculationData = null;

        // Opcional: Resetar formulÃ¡rio para valores padrÃ£o ou vazios
        // document.getElementById('calculatorForm').reset();
        // objectives = [];
        // renderObjectivesList();

        // Esconder resultados e comparaÃ§Ã£o
        document.getElementById('resultsContainer').style.display = 'none';
        document.getElementById('comparisonContainer').style.display = 'none';
        document.getElementById('whatsappButton').style.display = 'none';
        document.getElementById('saveScenarioButton').disabled = true;
    }

    // --- FunÃ§Ãµes de ComparaÃ§Ã£o de CenÃ¡rios (Adaptadas) ---
    function analyzeScenarios() {
        const checkboxes = document.querySelectorAll('input[name="compareScenario"]:checked');
        const selectedIndices = Array.from(checkboxes).map(cb => parseInt(cb.value));

        if (selectedIndices.length < 2) {
            alert("Selecione pelo menos dois cenÃ¡rios para comparar.");
            return;
        }

        const scenariosToCompare = selectedIndices.map(index => scenarios[index]);
        document.getElementById('comparisonContainer').style.display = 'block';
        drawComparisonChart(scenariosToCompare);
        fillComparisonTable(scenariosToCompare);
        generateGeneralAnalysis(scenariosToCompare);
    }

    function drawComparisonChart(scenariosToCompare) {
        const canvasId = 'comparisonChart';
        const ctx = document.getElementById(canvasId).getContext('2d');
        if (chartInstances[canvasId]) {
            chartInstances[canvasId].destroy();
        }

        const datasets = [];
        let maxMonths = 0;
        const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'];

        scenariosToCompare.forEach((scenario, index) => {
            const simData = scenario.data.results.mainSimulation.valoresMensais;
            if (simData && simData.length > 0) {
                maxMonths = Math.max(maxMonths, simData[simData.length - 1].month);
                datasets.push({
                    label: `${scenario.name} (LÃ­quido)`,
                    data: simData.map(d => ({ x: d.month, y: d.valorLiquido })),
                    borderColor: colors[index % colors.length],
                    fill: false,
                    tension: 0.1
                });
            }
        });

        const labels = Array.from({ length: maxMonths + 1 }, (_, i) => i);

        chartInstances[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Meses'
                        },
                        type: 'linear', // Usar escala linear para meses
                        ticks: {
                            stepSize: Math.max(1, Math.floor(maxMonths / 10)) // Ajustar step size
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Valor LÃ­quido (R$)'
                        },
                        ticks: {
                            callback: function(value) {
                                return formatCurrencyValue(value);
                            }
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += formatCurrencyValue(context.parsed.y);
                                }
                                return label;
                            }
                        }
                    },
                    title: {
                        display: true,
                        text: 'ComparaÃ§Ã£o de Valor LÃ­quido entre CenÃ¡rios'
                    }
                }
            }
        });
    }

    function fillComparisonTable(scenariosToCompare) {
        const table = document.getElementById('comparisonTable');
        table.innerHTML = ''; // Limpar

        const metrics = [
            { key: 'initialSavings', label: 'Valor Inicial', format: formatCurrencyValue },
            { key: 'monthlyContribution', label: 'Aporte Mensal', format: formatCurrencyValue },
            { key: 'interestRate', label: 'Taxa Juros', format: (v, p) => `${v.toFixed(2).replace('.',',')}% ${p.interestRateType === 'anual' ? 'a.a.' : 'a.m.'}` },
            { key: 'taxRate', label: 'IR', format: formatPercentageValue },
            { key: 'annualInflation', label: 'InflaÃ§Ã£o', format: formatPercentageValue },
            { key: 'finalNetValue', label: 'Valor LÃ­quido Final', format: formatCurrencyValue, resultPath: 'mainSimulation.valoresMensais', isResult: true, agg: 'last' },
            { key: 'finalGrossValue', label: 'Valor Bruto Final', format: formatCurrencyValue, resultPath: 'mainSimulation.valoresMensais', isResult: true, agg: 'last', dataKey: 'totalAcumulado' },
            { key: 'totalInvested', label: 'Total Investido Final', format: formatCurrencyValue, resultPath: 'mainSimulation.valoresMensais', isResult: true, agg: 'last' },
            { key: 'totalJuros', label: 'Total Juros Final', format: formatCurrencyValue, resultPath: 'mainSimulation.valoresMensais', isResult: true, agg: 'last' },
            { key: 'totalImposto', label: 'Total Imposto Final', format: formatCurrencyValue, resultPath: 'mainSimulation.valoresMensais', isResult: true, agg: 'last', dataKey: 'imposto' },
            { key: 'requiredInitialValue', label: 'Valor Inicial Ideal', format: formatCurrencyValue, resultPath: 'requiredInitialValue.value', isResult: true },
            { key: 'idealContribution', label: 'Aporte Ideal', format: formatCurrencyValue, resultPath: 'idealContribution.value', isResult: true },
            { key: 'requiredTime', label: 'Tempo Ideal (meses)', format: (v) => v === Infinity ? '> 100 anos' : v, resultPath: 'requiredTime.value', isResult: true },
            { key: 'idealRate', label: 'Taxa Anual Ideal', format: formatPercentageValue, resultPath: 'idealRate.value', isResult: true },
        ];

        // CabeÃ§alho
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        const thMetric = document.createElement('th');
        thMetric.textContent = 'MÃ©trica';
        headerRow.appendChild(thMetric);
        scenariosToCompare.forEach(scenario => {
            const th = document.createElement('th');
            th.textContent = scenario.name;
            headerRow.appendChild(th);
        });

        // Corpo
        const tbody = table.createTBody();
        metrics.forEach(metric => {
            const row = tbody.insertRow();
            const cellMetric = row.insertCell();
            cellMetric.textContent = metric.label;
            cellMetric.style.fontWeight = 'bold';
            cellMetric.style.textAlign = 'left';

            const values = [];
            scenariosToCompare.forEach(scenario => {
                let value = null;
                try {
                    if (metric.isResult) {
                        let path = metric.resultPath.split('.');
                        let current = scenario.data.results;
                        path.forEach(part => { current = current[part]; });
                        if (metric.agg === 'last') {
                            const dataKey = metric.dataKey || path[path.length - 1]; // Default to last part if no dataKey
                            value = current && current.length > 0 ? current[current.length - 1][dataKey] : null;
                        } else {
                            value = current;
                        }
                    } else {
                        value = scenario.data.params[metric.key];
                    }
                } catch (e) {
                    console.error(`Error accessing metric ${metric.key} for scenario ${scenario.name}:`, e);
                    value = null;
                }
                values.push(value);

                const cell = row.insertCell();
                const formattedValue = metric.format(value, scenario.data.params);
                cell.textContent = formattedValue;
            });

            // Highlight best/worst for numeric results
            if (metric.isResult && values.every(v => typeof v === 'number' && v !== Infinity && !isNaN(v))) {
                const numericValues = values.filter(v => v !== null);
                if (numericValues.length > 1) {
                    const maxVal = Math.max(...numericValues);
                    const minVal = Math.min(...numericValues);
                    row.cells.forEach((cell, i) => {
                        if (i > 0) { // Skip metric label cell
                            const val = values[i-1];
                            if (val === maxVal) cell.classList.add('best-value');
                            if (val === minVal) cell.classList.add('worst-value');
                        }
                    });
                }
            }
        });
    }

    function generateGeneralAnalysis(scenariosToCompare) {
        const container = document.getElementById('generalAnalysisContent');
        let analysisHTML = '';

        // Exemplo: Comparar valor lÃ­quido final
        let bestNetValue = -Infinity;
        let bestNetScenario = '';
        let worstNetValue = Infinity;
        let worstNetScenario = '';

        scenariosToCompare.forEach(scenario => {
            try {
                const simData = scenario.data.results.mainSimulation.valoresMensais;
                if (simData && simData.length > 0) {
                    const finalNet = simData[simData.length - 1].valorLiquido;
                    if (finalNet > bestNetValue) {
                        bestNetValue = finalNet;
                        bestNetScenario = scenario.name;
                    }
                    if (finalNet < worstNetValue) {
                        worstNetValue = finalNet;
                        worstNetScenario = scenario.name;
                    }
                }
            } catch (e) {}
        });

        if (bestNetScenario) {
            analysisHTML += `<p><strong>Maior Valor LÃ­quido Final:</strong> ${bestNetScenario} (${formatCurrencyValue(bestNetValue)})</p>`;
        }
        if (worstNetScenario && worstNetScenario !== bestNetScenario) {
             analysisHTML += `<p><strong>Menor Valor LÃ­quido Final:</strong> ${worstNetScenario} (${formatCurrencyValue(worstNetValue)})</p>`;
        }

        // Adicionar mais anÃ¡lises comparativas aqui (ex: qual atinge mais rÃ¡pido, qual precisa de menor aporte ideal, etc.)
        // Exemplo: Menor tempo ideal
        let bestTime = Infinity;
        let bestTimeScenario = '';
        scenariosToCompare.forEach(scenario => {
             try {
                 const time = scenario.data.results.requiredTime.value;
                 if (time < bestTime) {
                     bestTime = time;
                     bestTimeScenario = scenario.name;
                 }
             } catch(e) {}
        });
        if (bestTimeScenario) {
             analysisHTML += `<p><strong>Menor Tempo Ideal para Atingir Objetivos:</strong> ${bestTimeScenario} (${bestTime === Infinity ? '> 100 anos' : `${bestTime} meses`})</p>`;
        }

        container.innerHTML = analysisHTML || '<p>NÃ£o foi possÃ­vel gerar anÃ¡lise comparativa detalhada.</p>';
        document.getElementById('generalAnalysisContainer').style.display = 'block';
    }

    // --- InicializaÃ§Ã£o --- //
    document.addEventListener('DOMContentLoaded', () => {
        // Carregar cenÃ¡rios salvos do localStorage (se houver)
        const savedScenarios = localStorage.getItem('financialScenarios');
        if (savedScenarios) {
            scenarios = JSON.parse(savedScenarios);
            renderSavedScenarios();
            document.getElementById('analyzeScenarioButton').disabled = scenarios.length < 2;
        }
        // Adicionar listener para salvar no localStorage ao fechar
        window.addEventListener('beforeunload', () => {
            localStorage.setItem('financialScenarios', JSON.stringify(scenarios));
        });

        // Formatar campos iniciais
        formatCurrency(document.getElementById('initialSavings'));
        formatCurrency(document.getElementById('monthlyContribution'));
        formatPercentage(document.getElementById('interestRate'));
        formatPercentage(document.getElementById('taxRate'));
        formatPercentage(document.getElementById('annualInflation'));
    });

</script>
</body>
</html>

