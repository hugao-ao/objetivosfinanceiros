<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Calculadora de Múltiplos Objetivos Avançada</title>
  <link rel="icon" href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    :root {
      --verde-esmeralda: #046c4e;
      --verde-esmeralda-escuro: #034e38;
      --verde-claro: #28a745;
      --verde-medio: #218838;
      --dourado: #d4af37;
      --dourado-claro: #f5e2a9;
      --dourado-escuro: #b38e2e;
      --roxo: #6f42c1;
      --roxo-claro: #9f75e5;
      --roxo-escuro: #4b2882;
      --fundo-claro: #f9f9f9;
      --fundo-container: #ffffff;
      --vermelho-translucido: rgba(255, 0, 0, 0.1);
      --azul-translucido: rgba(0, 0, 255, 0.1);
      --roxo-translucido: rgba(111, 66, 193, 0.1);
      --cinza-claro: #e9ecef;
      --cinza-medio: #ced4da;
      --cinza-escuro: #6c757d;
      --verde-destaque: rgba(4, 108, 78, 0.1);
      --vermelho-destaque: rgba(220, 53, 69, 0.1);
      --sombra-padrao: 0 4px 12px rgba(0,0,0,0.1);
      --borda-arredondada: 8px;
      --espacamento-padrao: 20px;
      --transicao-padrao: all 0.3s ease;
    }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background-color: var(--fundo-claro);
      color: var(--verde-esmeralda-escuro);
      margin: 0;
      padding: var(--espacamento-padrao);
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
      line-height: 1.6;
    }
    h1, h2, h3, h4, h5, h6 {
      color: var(--verde-esmeralda);
      margin-top: 0;
      margin-bottom: var(--espacamento-padrao);
      font-weight: 600;
      line-height: 1.3;
    }
    h1 {
      color: var(--verde-esmeralda-escuro);
      text-align: center;
      font-size: 2.2rem;
      margin-bottom: 1.5rem;
      border-bottom: 3px solid var(--dourado);
      padding-bottom: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    form {
      background-color: var(--fundo-container);
      padding: var(--espacamento-padrao);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
      margin-bottom: var(--espacamento-padrao);
      border: 1px solid var(--cinza-claro);
    }
    .result {
      margin-top: var(--espacamento-padrao);
      padding: var(--espacamento-padrao);
      border: 2px solid var(--dourado);
      background-color: var(--fundo-container);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
    }
    .result h4 {
        color: var(--verde-esmeralda-escuro);
        border-bottom: 1px solid var(--dourado-claro);
        padding-bottom: 10px;
        margin-bottom: 15px;
    }
    .recommendation {
      margin: var(--espacamento-padrao) 0;
      padding: var(--espacamento-padrao);
      border: 2px solid var(--verde-esmeralda);
      background-color: var(--fundo-container);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
    }
    .recommendation h3 {
      color: var(--verde-esmeralda-escuro);
      margin-top: 0;
      border-bottom: 2px solid var(--dourado);
      padding-bottom: 10px;
      font-size: 1.4rem;
    }
    .whatsapp-button {
      display: block;
      width: 100%;
      padding: 15px;
      margin: var(--espacamento-padrao) 0;
      background-color: var(--verde-esmeralda);
      color: white;
      text-align: center;
      font-weight: bold;
      font-size: 1.2rem;
      border: none;
      border-radius: var(--borda-arredondada);
      cursor: pointer;
      text-decoration: none;
      box-shadow: var(--sombra-padrao);
      transition: var(--transicao-padrao);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .whatsapp-button:hover {
      background-color: var(--verde-esmeralda-escuro);
      transform: translateY(-2px);
    }
    .save-scenario-button, .analyze-scenario-button, .new-scenario-button {
      display: block;
      width: 100%;
      padding: 15px;
      margin: var(--espacamento-padrao) 0;
      color: white;
      text-align: center;
      font-weight: bold;
      font-size: 1rem;
      border: none;
      border-radius: var(--borda-arredondada);
      cursor: pointer;
      text-decoration: none;
      box-shadow: var(--sombra-padrao);
      transition: var(--transicao-padrao);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .save-scenario-button { background-color: var(--dourado); }
    .save-scenario-button:hover { background-color: var(--dourado-escuro); transform: translateY(-2px); }
    .analyze-scenario-button { background-color: var(--verde-esmeralda); }
    .analyze-scenario-button:hover { background-color: var(--verde-esmeralda-escuro); transform: translateY(-2px); }
    .new-scenario-button { background-color: var(--dourado); }
    .new-scenario-button:hover { background-color: var(--dourado-escuro); transform: translateY(-2px); }

    label {
      display: block;
      margin-top: 15px;
      margin-bottom: 5px;
      font-weight: 500;
      color: var(--verde-esmeralda-escuro);
    }
    .row {
      display: flex;
      flex-wrap: wrap; /* Allow wrapping on smaller screens */
      justify-content: space-between;
      gap: 15px;
      margin-bottom: 15px;
    }
    .row > div {
      flex: 1;
      min-width: 150px; /* Prevent fields from becoming too narrow */
    }
    input, select, textarea {
      width: 100%;
      padding: 12px;
      margin-top: 5px;
      box-sizing: border-box;
      border: 1px solid var(--cinza-medio);
      border-radius: var(--borda-arredondada);
      transition: var(--transicao-padrao);
      font-size: 1rem;
    }
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--dourado);
      box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
    }
    textarea {
      min-height: 80px; /* Reduced height */
      resize: vertical;
    }
    button {
      margin-top: 20px;
      padding: 14px;
      background-color: var(--verde-esmeralda);
      color: white;
      border: none;
      border-radius: var(--borda-arredondada);
      cursor: pointer;
      width: 100%;
      font-weight: bold;
      font-size: 1rem;
      transition: var(--transicao-padrao);
      letter-spacing: 0.5px;
    }
    button:hover {
      background-color: var(--verde-esmeralda-escuro);
      transform: translateY(-2px);
    }
    .chart-container {
      margin-top: 30px;
      position: relative;
      border: 2px solid var(--dourado-claro);
      border-radius: var(--borda-arredondada);
      padding: 20px;
      background-color: var(--fundo-container);
      box-shadow: var(--sombra-padrao);
    }
    .chart-title {
      text-align: center;
      font-weight: bold;
      margin-bottom: 20px;
      color: var(--verde-esmeralda-escuro);
      font-size: 1.2rem;
      border-bottom: 1px solid var(--dourado);
      padding-bottom: 10px;
    }
    .chart-nav {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 15px;
    }
    .chart-nav button {
      padding: 10px 20px;
      margin-top: 0;
      width: auto;
      font-size: 0.9rem;
      background-color: var(--dourado);
      border-radius: var(--borda-arredondada);
      transition: var(--transicao-padrao);
    }
    .chart-nav button:hover {
      background-color: var(--dourado-escuro);
    }
    .chart-content {
      display: flex;
      overflow: hidden;
      position: relative;
      height: 400px;
      border: 1px solid var(--cinza-claro);
      border-radius: var(--borda-arredondada);
      background-color: var(--fundo-container);
    }
    .chart-slide {
      flex: 0 0 100%;
      transition: transform 0.3s ease;
    }
    .table-slide {
      flex: 0 0 100%;
      overflow-x: auto;
      overflow-y: auto;
      padding: 15px;
      background-color: var(--fundo-container);
      max-height: 400px; /* Limit table height */
    }
    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
      min-width: 800px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    .data-table th, .data-table td {
      border: 1px solid var(--cinza-claro);
      padding: 10px;
      text-align: right;
      white-space: nowrap;
    }
    .data-table th {
      background-color: var(--verde-esmeralda);
      color: white;
      font-weight: 600;
      text-align: center;
      text-transform: uppercase;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .data-table tr:nth-child(even) {
      background-color: var(--verde-destaque);
    }
    .data-table tr:hover {
      background-color: var(--dourado-claro);
    }
    .scenarios-container {
      margin: 30px 0;
      padding: 20px;
      border: 2px solid var(--dourado);
      background-color: var(--fundo-container);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
    }
    .scenarios-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 2px solid var(--verde-esmeralda);
      padding-bottom: 10px;
    }
    .scenarios-header h3 {
      color: var(--verde-esmeralda-escuro);
      margin: 0;
      font-size: 1.4rem;
    }
    .scenario-card {
      border: 1px solid var(--cinza-medio);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      background-color: var(--cinza-claro);
      position: relative;
    }
    .scenario-card.active {
      border: 2px solid var(--verde-esmeralda);
      background-color: white;
    }
    .scenario-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .scenario-title {
      font-weight: bold;
      color: var(--verde-esmeralda);
      margin: 0;
    }
    .scenario-actions {
      display: flex;
      gap: 10px;
    }
    .scenario-actions button {
      padding: 5px 10px;
      margin: 0;
      width: auto;
      font-size: 12px;
    }
    .scenario-delete {
      background-color: #dc3545;
    }
    .scenario-delete:hover {
      background-color: #c82333;
    }
    .scenario-select {
      background-color: var(--dourado);
    }
    .scenario-select:hover {
      background-color: var(--dourado-escuro);
    }
    .scenario-content {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .scenario-info {
      flex: 1;
      min-width: 200px;
    }
    .scenario-info p {
      margin: 5px 0;
    }
    .scenario-info strong {
      color: var(--verde-esmeralda);
    }
    .scenario-details {
      margin-top: 10px;
      padding: 10px;
      background-color: var(--fundo-claro);
      border-radius: 5px;
      font-size: 14px;
    }
    .scenario-details ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .scenario-details li {
      margin-bottom: 5px;
    }
    /* Estilos para comparação de cenários */
    .comparison-container {
      margin-top: 30px;
      border: 2px solid var(--roxo);
      border-radius: 8px;
      padding: 15px;
      background-color: white;
    }
    .comparison-header {
      color: var(--roxo);
      margin-top: 0;
      border-bottom: 1px solid var(--dourado-claro);
      padding-bottom: 10px;
      text-align: center;
    }
    .comparison-chart-container {
      height: 400px;
      margin: 20px 0;
    }
    #comparisonTableContainer {
      overflow-x: auto; /* Habilitar rolagem horizontal */
    }
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      min-width: 900px; /* Garantir largura mínima para forçar rolagem se necessário */
    }
    .comparison-table th, .comparison-table td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: center;
      white-space: nowrap; /* Evitar quebra de linha nas células */
    }
    .comparison-table th {
      background-color: var(--roxo-translucido);
      color: var(--roxo-escuro);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .comparison-table tr:nth-child(even) {
      background-color: var(--fundo-claro);
    }
    .comparison-table .best-value {
      font-weight: bold;
      color: var(--verde-esmeralda);
      background-color: var(--verde-destaque);
    }
    .comparison-table .worst-value {
      font-weight: bold;
      color: #dc3545;
      background-color: var(--vermelho-destaque);
    }
    .general-analysis {
      margin-top: 30px;
      padding: 20px;
      border: 2px solid var(--roxo);
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .general-analysis h3 {
      color: var(--roxo);
      margin-top: 0;
      border-bottom: 1px solid var(--dourado-claro);
      padding-bottom: 10px;
      text-align: center;
    }

    /* Estilos para a seção de múltiplos objetivos */
    .objectives-section {
      background-color: var(--fundo-container);
      padding: var(--espacamento-padrao);
      border-radius: var(--borda-arredondada);
      box-shadow: var(--sombra-padrao);
      margin-bottom: var(--espacamento-padrao);
      border: 1px solid var(--cinza-claro);
    }
    .objectives-section h3 {
      color: var(--verde-esmeralda);
      margin-top: 0;
      margin-bottom: 15px;
      border-bottom: 2px solid var(--dourado);
      padding-bottom: 10px;
    }
    .objective-input-group {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      align-items: flex-end; /* Align items to bottom for button */
      margin-bottom: 15px;
    }
    .objective-input-group > div {
      flex: 1;
      min-width: 120px;
    }
    .objective-input-group button {
      flex-basis: 100px; /* Fixed width for button */
      margin-top: 0; /* Remove default top margin */
      padding: 12px; /* Match input padding */
      height: 46px; /* Match input height */
      font-size: 0.9rem;
      width: auto;
    }
    #objectivesList {
      margin-top: 15px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--cinza-medio);
      border-radius: var(--borda-arredondada);
      padding: 10px;
    }
    .objective-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid var(--cinza-claro);
      background-color: var(--fundo-claro);
      border-radius: 4px;
      margin-bottom: 5px;
    }
    .objective-item:last-child {
      border-bottom: none;
    }
    .objective-item span {
      flex-grow: 1;
      margin-right: 10px;
      font-size: 0.9rem;
    }
    .objective-item button {
      padding: 4px 8px;
      margin: 0;
      width: auto;
      font-size: 0.8rem;
      background-color: #dc3545;
      line-height: 1;
    }
    .objective-item button:hover {
      background-color: #c82333;
    }

  </style>
</head>
<body>
  <h1>Calculadora de Múltiplos Objetivos Avançada</h1>

  <!-- Seção para Adicionar/Gerenciar Objetivos -->
  <div class="objectives-section">
    <h3>Seus Objetivos</h3>
    <div class="objective-input-group">
      <div>
        <label for="newObjectiveDescription">Descrição</label>
        <input type="text" id="newObjectiveDescription" placeholder="Ex: Viagem Europa">
      </div>
      <div>
        <label for="newObjectiveValue">Valor (R$)</label>
        <input type="text" id="newObjectiveValue" placeholder="R$ 15.000,00" oninput="formatCurrency(this)">
      </div>
      <div>
        <label for="newObjectivePeriod">Prazo (meses)</label>
        <input type="number" id="newObjectivePeriod" placeholder="24">
      </div>
      <button type="button" onclick="addObjective()">Adicionar</button>
    </div>
    <div id="objectivesListContainer">
      <label>Objetivos Adicionados:</label>
      <div id="objectivesList">
        <!-- Objetivos serão listados aqui -->
        <p style="text-align: center; color: var(--cinza-escuro);">Nenhum objetivo adicionado ainda.</p>
      </div>
    </div>
  </div>

  <!-- Formulário Principal com Parâmetros Financeiros Comuns -->
  <form id="savingsForm" onsubmit="event.preventDefault(); calculateSavings();">
    <h3>Parâmetros Financeiros</h3>

    <label for="currentSavings">Valor já Guardado (R$):</label>
    <input type="text" id="currentSavings" required oninput="formatCurrency(this)">

    <label for="currentContribution">Quanto você poupa atualmente por mês (R$):</label>
    <input type="text" id="currentContribution" required oninput="formatCurrency(this)">

    <div class="row">
      <div>
        <label for="rate">Taxa de Juros (%):</label>
        <input type="text" id="rate" required oninput="formatPercentage(this)">
      </div>
      <div>
        <label for="rateType">Tipo de Taxa:</label>
        <select id="rateType">
          <option value="annual">Anual</option>
          <option value="monthly">Mensal</option>
        </select>
      </div>
    </div>

    <label>Você sabe a alíquota de imposto sobre o rendimento?</label>
    <div class="row">
      <div>
        <select id="knowsTax" onchange="toggleTaxInput('tax', '15,00 %')">
          <option value="no">Não</option>
          <option value="yes">Sim</option>
        </select>
      </div>
      <div>
        <input type="text" id="tax" placeholder="15,00 %" value="15,00 %" oninput="formatPercentage(this)" disabled>
      </div>
    </div>

    <label>Você sabe a taxa de inflação anual?</label>
    <div class="row">
      <div>
        <select id="knowsInflation" onchange="toggleTaxInput('inflation', '5,00 %')">
          <option value="no">Não</option>
          <option value="yes">Sim</option>
        </select>
      </div>
      <div>
        <input type="text" id="inflation" placeholder="5,00 %" value="5,00 %" oninput="formatPercentage(this)" disabled>
      </div>
    </div>

    <button type="submit">Calcular Cenário</button>
  </form>

  <div id="result" class="result" style="display: none;"></div>

  <div id="recommendation" class="recommendation" style="display: none;">
    <h3>Análise Automatizada</h3>
    <div id="recommendationText"></div>
  </div>

  <!-- Botões para salvar cenário, analisar cenários e simular outro cenário -->
  <div class="row" style="margin-top: 20px;">
    <div style="flex: 1; margin-right: 10px;">
      <button id="saveScenarioButton" class="save-scenario-button" type="button" onclick="addCurrentScenario()" style="display: none;">
        SALVAR CENÁRIO
      </button>
    </div>
    <div style="flex: 1; margin-left: 10px; margin-right: 10px;">
      <button id="analyzeScenarioButton" class="analyze-scenario-button" type="button" onclick="analyzeScenarios()" style="display: none;">
        ANALISAR CENÁRIOS
      </button>
    </div>
    <div style="flex: 1; margin-left: 10px;">
      <button id="newScenarioButton" class="new-scenario-button" type="button" onclick="prepareNewScenario()" style="display: none;">
        LIMPAR PARA NOVO CÁLCULO
      </button>
    </div>
  </div>

  <!-- Botão WhatsApp para análise personalizada - sempre visível após cálculo -->
  <a id="whatsappButton" href="#" class="whatsapp-button" onclick="openWhatsAppChat()" style="display: none;">
    AVANÇAR PARA ANÁLISE PERSONALIZADA
  </a>

  <!-- Container Único para Gráfico/Tabela de Projeção -->
  <div id="projectionChartContainer" class="chart-container" style="display: none;">
    <div class="chart-title">Evolução da Projeção Financeira</div>
    <div class="chart-nav">
      <button type="button" onclick="showChartSlide('Projection', 'chart')">Gráfico</button>
      <button type="button" onclick="showChartSlide('Projection', 'table')">Memória de Cálculo</button>
    </div>
    <div class="chart-content">
      <div id="chartProjectionSlide" class="chart-slide">
        <canvas id="chartProjection"></canvas>
      </div>
      <div id="tableProjectionSlide" class="table-slide" style="display: none;">
        <table id="tableProjection" class="data-table">
          <thead>
            <tr>
              <th scope="col">Mês</th>
              <th scope="col">Total Investido</th>
              <th scope="col">Juros</th>
              <th scope="col">Total Juros</th>
              <th scope="col">Total Acumulado</th>
              <th scope="col">Imposto</th>
              <th scope="col">Valor Líquido</th>
              <!-- Coluna de Objetivo Corrigido pode ser adicionada se necessário -->
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Container para Análise 1: Valor Inicial Necessário -->
  <div id="analysisInitialValueContainer" class="chart-container" style="display: none; border-color: var(--verde-claro);">
    <div class="chart-title">Análise: Valor Inicial Necessário (sem aportes)</div>
    <p id="resultInitialValue" style="text-align: center; font-weight: bold; margin-bottom: 15px;"></p>
    <div class="chart-nav">
      <button type="button" onclick="showChartSlide(\'InitialValue\', \'chart\')">Gráfico</button>
      <button type="button" onclick="showChartSlide(\'InitialValue\', \'table\')">Memória de Cálculo</button>
    </div>
    <div class="chart-content">
      <div id="chartInitialValueSlide" class="chart-slide">
        <canvas id="chartInitialValue"></canvas>
      </div>
      <div id="tableInitialValueSlide" class="table-slide" style="display: none;">
        <table id="tableInitialValue" class="data-table">
          <thead>
            <tr>
              <th scope="col">Mês</th><th scope="col">Total Investido</th><th scope="col">Juros</th><th scope="col">Total Juros</th><th scope="col">Total Acumulado</th><th scope="col">Imposto</th><th scope="col">Valor Líquido</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Container para Análise 2: Aporte Mensal Ideal -->
  <div id="analysisIdealContributionContainer" class="chart-container" style="display: none; border-color: var(--verde-medio);">
    <div class="chart-title">Análise: Aporte Mensal Ideal</div>
    <p id="resultIdealContribution" style="text-align: center; font-weight: bold; margin-bottom: 15px;"></p>
    <div class="chart-nav">
      <button type="button" onclick="showChartSlide(\'IdealContribution\', \'chart\')">Gráfico</button>
      <button type="button" onclick="showChartSlide(\'IdealContribution\', \'table\')">Memória de Cálculo</button>
    </div>
    <div class="chart-content">
      <div id="chartIdealContributionSlide" class="chart-slide">
        <canvas id="chartIdealContribution"></canvas>
      </div>
      <div id="tableIdealContributionSlide" class="table-slide" style="display: none;">
        <table id="tableIdealContribution" class="data-table">
          <thead>
             <tr>
              <th scope="col">Mês</th><th scope="col">Total Investido</th><th scope="col">Juros</th><th scope="col">Total Juros</th><th scope="col">Total Acumulado</th><th scope="col">Imposto</th><th scope="col">Valor Líquido</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Container para Análise 3: Tempo Necessário -->
  <div id="analysisRequiredTimeContainer" class="chart-container" style="display: none; border-color: var(--roxo-claro);">
    <div class="chart-title">Análise: Tempo Necessário</div>
    <p id="resultRequiredTime" style="text-align: center; font-weight: bold; margin-bottom: 15px;"></p>
    <div class="chart-nav">
      <button type="button" onclick="showChartSlide(\'RequiredTime\', \'chart\')">Gráfico</button>
      <button type="button" onclick="showChartSlide(\'RequiredTime\', \'table\')">Memória de Cálculo</button>
    </div>
    <div class="chart-content">
      <div id="chartRequiredTimeSlide" class="chart-slide">
        <canvas id="chartRequiredTime"></canvas>
      </div>
      <div id="tableRequiredTimeSlide" class="table-slide" style="display: none;">
        <table id="tableRequiredTime" class="data-table">
          <thead>
             <tr>
              <th scope="col">Mês</th><th scope="col">Total Investido</th><th scope="col">Juros</th><th scope="col">Total Juros</th><th scope="col">Total Acumulado</th><th scope="col">Imposto</th><th scope="col">Valor Líquido</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Container para Análise 4: Rentabilidade Anual Ideal -->
  <div id="analysisIdealRateContainer" class="chart-container" style="display: none; border-color: var(--dourado-escuro);">
    <div class="chart-title">Análise: Rentabilidade Anual Ideal</div>
    <p id="resultIdealRate" style="text-align: center; font-weight: bold; margin-bottom: 15px;"></p>
    <div class="chart-nav">
      <button type="button" onclick="showChartSlide(\'IdealRate\', \'chart\')">Gráfico</button>
      <button type="button" onclick="showChartSlide(\'IdealRate\', \'table\')">Memória de Cálculo</button>
    </div>
    <div class="chart-content">
      <div id="chartIdealRateSlide" class="chart-slide">
        <canvas id="chartIdealRate"></canvas>
      </div>
      <div id="tableIdealRateSlide" class="table-slide" style="display: none;">
        <table id="tableIdealRate" class="data-table">
          <thead>
             <tr>
              <th scope="col">Mês</th><th scope="col">Total Investido</th><th scope="col">Juros</th><th scope="col">Total Juros</th><th scope="col">Total Acumulado</th><th scope="col">Imposto</th><th scope="col">Valor Líquido</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Container para Cenários Salvos -->
  <div id="scenariosContainer" class="scenarios-container" style="display: none;">
    <div class="scenarios-header">
      <h3>Cenários Salvos</h3>
    </div>
    <div id="scenariosList"></div>
  </div>

  <!-- Container para Comparação de Cenários -->
  <div id="comparisonContainer" class="comparison-container" style="display: none;">
    <h3 class="comparison-header">Comparação de Cenários</h3>
    <div id="comparisonChartContainer" class="comparison-chart-container">
      <canvas id="comparisonChart"></canvas>
    </div>
    <div id="comparisonTableContainer">
      <table id="comparisonTable" class="comparison-table">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Container para Análise Geral -->
   <div id="generalAnalysis" class="general-analysis" style="display: none;">
    <h3>Análise Geral dos Cenários</h3>
    <div id="generalAnalysisText"></div>
  </div>


  <script>
    // --- Variáveis Globais ---
    let objectives = []; // Array para armazenar os múltiplos objetivos
    let scenarios = []; // Array para armazenar os cenários salvos
    let scenarioCounter = 1; // Contador para nomeação automática de cenários
    let currentCalculationData = null; // Armazena os dados do cálculo atual
    let projectionChart = null; // Referência para o gráfico de projeção
    let comparisonChart = null; // Referência para o gráfico de comparação
    // Referências para os gráficos das análises adicionais
    let initialValueChart = null;
    let idealContributionChart = null;
    let requiredTimeChart = null;
    let idealRateChart = null;

    // --- Funções de Formatação e Utilitários ---
    function formatCurrency(input) {
      let value = input.value.replace(/\D/g, "");
      value = (parseFloat(value) / 100).toFixed(2);
      if (isNaN(value) || value === "NaN") value = "0.00";
      input.value = "R$ " + parseFloat(value).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    function formatPercentage(input) {
      let value = input.value.replace(/[^\d,]/g, "").replace(",", "."); // Permite vírgula como decimal
      value = parseFloat(value);
      if (isNaN(value)) value = 0;
      // Formata com duas casas decimais e vírgula
      input.value = value.toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2}) + " %";
    }

    function toggleTaxInput(id, defaultValue) {
      const selectElementId = id === "tax" ? "knowsTax" : "knowsInflation";
      const select = document.getElementById(selectElementId);
      const input = document.getElementById(id);
      if (select.value === "yes") {
        input.disabled = false;
        input.value = ""; // Limpa o valor se o usuário sabe
        input.placeholder = defaultValue; // Mantém o placeholder como guia
      } else {
        input.disabled = true;
        input.value = defaultValue; // Define o valor padrão se o usuário não sabe
      }
    }

    function parseCurrency(value) {
      if (typeof value !== 'string') return 0;
      return parseFloat(value.replace(/R\$\s?/g, "").replace(/\./g, "").replace(",", ".")) || 0;
    }

    function parsePercentage(value) {
       if (typeof value !== 'string') return 0;
      return parseFloat(value.replace(/%\s?/g, "").replace(",", ".")) / 100 || 0;
    }

    function formatMoney(value) {
        if (typeof value !== 'number' || isNaN(value) || !isFinite(value)) {
            return "N/A"; // Retorna N/A para valores inválidos ou infinitos
        }
        return "R$ " + value.toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    function formatMonths(months) {
        if (typeof months !== 'number' || isNaN(months) || !isFinite(months)) {
            return "N/A";
        }
        if (months === Infinity) return "Inatingível";
        const years = Math.floor(months / 12);
        const remainingMonths = months % 12;
        let result = "";
        if (years > 0) {
            result += `${years} ano${years > 1 ? 's' : ''}`;
        }
        if (remainingMonths > 0) {
            if (years > 0) result += " e ";
            result += `${remainingMonths} ${remainingMonths > 1 ? 'meses' : 'mês'}`;
        }
        if (result === "") result = "0 meses"; // Caso months seja 0
        return result;
    }

    function formatRate(rate) {
         if (typeof rate !== 'number' || isNaN(rate) || !isFinite(rate)) {
            return "N/A";
        }
        if (rate === Infinity) return "Inatingível";
        return (rate * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2}) + "% a.a.";
    }

    function showChartSlide(containerId, slideType) {
      const chartSlide = document.getElementById(`chart${containerId}Slide`);
      const tableSlide = document.getElementById(`table${containerId}Slide`);

      if (slideType === "chart") {
        chartSlide.style.display = "block";
        tableSlide.style.display = "none";
      } else {
        chartSlide.style.display = "none";
        tableSlide.style.display = "block";
      }
    }

    // --- Funções de Gerenciamento de Objetivos ---
    function addObjective() {
      const descriptionInput = document.getElementById("newObjectiveDescription");
      const valueInput = document.getElementById("newObjectiveValue");
      const periodInput = document.getElementById("newObjectivePeriod");

      const description = descriptionInput.value.trim();
      const value = parseCurrency(valueInput.value);
      const period = parseInt(periodInput.value);

      if (!description) {
        alert("Por favor, insira uma descrição para o objetivo.");
        return;
      }
      if (isNaN(value) || value <= 0) {
        alert("Por favor, insira um valor válido para o objetivo.");
        return;
      }
      if (isNaN(period) || period <= 0) {
        alert("Por favor, insira um prazo válido (em meses) para o objetivo.");
        return;
      }

      objectives.push({ description, value, period });
      displayObjectives();

      // Limpar campos
      descriptionInput.value = "";
      valueInput.value = "";
      periodInput.value = "";
    }

    function deleteObjective(index) {
      objectives.splice(index, 1);
      displayObjectives();
    }

    function displayObjectives() {
      const listDiv = document.getElementById("objectivesList");
      listDiv.innerHTML = ""; // Limpar lista

      if (objectives.length === 0) {
        listDiv.innerHTML = '<p style="text-align: center; color: var(--cinza-escuro);">Nenhum objetivo adicionado ainda.</p>';
        return;
      }

      objectives.forEach((obj, index) => {
        const item = document.createElement("div");
        item.className = "objective-item";
        item.innerHTML = `
          <span>${obj.description} - ${formatMoney(obj.value)} em ${obj.period} meses</span>
          <button type="button" onclick="deleteObjective(${index})">Excluir</button>
        `;
        listDiv.appendChild(item);
      });
    }

    // --- Funções de Cálculo Principal e Auxiliares ---
    function calculateCompoundInterest(initialValue, monthlyContribution, monthlyRate, maxMonths, tax, annualInflation) {
      let totalValue = initialValue;
      let totalInvested = initialValue;
      let totalJuros = 0;
      let valoresMensais = [];
      const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

      // Registrar valores iniciais (mês 0)
      valoresMensais.push({
        month: 0,
        juros: 0,
        totalInvestido: totalInvested,
        totalJuros: 0,
        imposto: 0,
        valorLiquido: totalValue,
        totalAcumulado: totalValue
      });

      for (let month = 1; month <= maxMonths; month++) {
        const jurosDoMes = totalValue * monthlyRate;
        totalJuros += jurosDoMes;
        totalValue += jurosDoMes + monthlyContribution;
        totalInvested += monthlyContribution;

        // Imposto calculado sobre o ganho de capital (Juros Totais)
        const impostoTotal = totalJuros * tax;
        const valorLiquido = totalValue - impostoTotal;

        valoresMensais.push({
          month: month,
          juros: jurosDoMes,
          totalInvestido: totalInvested,
          totalJuros: totalJuros,
          imposto: impostoTotal,
          valorLiquido: valorLiquido,
          totalAcumulado: totalValue
        });
      }

      return {
        finalValue: totalValue,
        totalInvested: totalInvested,
        totalJuros: totalJuros,
        totalImposto: totalJuros * tax,
        valoresMensais: valoresMensais
      };
    }

    // Função auxiliar para verificar se todos os objetivos são atingidos em uma simulação
    function checkAllObjectivesMet(objectives, valoresMensais, annualInflation) {
        if (!valoresMensais || valoresMensais.length === 0) return false;
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

        for (const obj of objectives) {
            const targetMonth = obj.period;
            if (targetMonth >= valoresMensais.length) {
                // Simulação não cobriu o prazo deste objetivo
                // console.log(`Simulação curta para ${obj.description} (Prazo: ${targetMonth}, Simulado: ${valoresMensais.length -1})`);
                return false;
            }
            const inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, targetMonth);
            const netValueAtTargetMonth = valoresMensais[targetMonth].valorLiquido;

            // console.log(`Obj: ${obj.description}, Mês: ${targetMonth}, Líquido: ${netValueAtTargetMonth}, Obj Corrigido: ${inflatedObjectiveValue}`);
            if (netValueAtTargetMonth < inflatedObjectiveValue) {
                // Este objetivo não foi atingido
                return false;
            }
        }
        // Se chegou aqui, todos os objetivos foram atingidos
        return true;
    }

    // --- Funções de Cálculo Adicionais --- //

    // 1. Calcular Valor Inicial Necessário (sem aportes) - Retorna { value: number | Infinity, simulation: object | null }
    function calculateRequiredInitialValue(objectives, monthlyRate, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        let low = 0;
        const maxPeriod = Math.max(...objectives.map(o => o.period), 0);
        if (maxPeriod <= 0) return { value: 0, simulation: null };
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;
        let high = objectives.reduce((sum, obj) => sum + obj.value * Math.pow(1 + monthlyInflation, obj.period), 0) * 1.5;

        let requiredInitialValue = Infinity;
        let finalSimulation = null;
        const maxIterations = 100;
        let iterations = 0;

        // Caso especial: taxa zero ou negativa
        if (monthlyRate <= 0) {
            let maxRequired = 0;
            for (const obj of objectives) {
                 const inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, obj.period);
                 maxRequired = Math.max(maxRequired, inflatedObjectiveValue);
            }
            const simulation = calculateCompoundInterest(maxRequired, 0, monthlyRate, maxPeriod, tax, annualInflation);
             if (checkAllObjectivesMet(objectives, simulation.valoresMensais, annualInflation)) {
                 return { value: maxRequired, simulation: simulation };
             } else {
                 return { value: Infinity, simulation: null };
             }
        }

        while (iterations < maxIterations && (high - low) > 0.01) {
            const mid = low + (high - low) / 2;
            if (mid === low || mid === high) break;

            const currentSim = calculateCompoundInterest(mid, 0, monthlyRate, maxPeriod, tax, annualInflation);

            if (checkAllObjectivesMet(objectives, currentSim.valoresMensais, annualInflation)) {
                requiredInitialValue = mid;
                finalSimulation = currentSim; // Guarda a simulação que funcionou
                high = mid;
            } else {
                low = mid;
            }
            iterations++;
        }

        if (requiredInitialValue === Infinity) {
            // Se não encontrou, retorna Infinity e nenhuma simulação
             return { value: Infinity, simulation: null };
        } else {
            // Retorna o valor encontrado e a simulação correspondente
            const finalValue = requiredInitialValue < 0.01 ? 0 : requiredInitialValue;
            // Recalcular a simulação final com o valor exato encontrado (se necessário, mas já temos finalSimulation)
            // Se o valor final for 0, a simulação deve ser recalculada
            if (finalValue === 0 && requiredInitialValue >= 0.01) {
                 finalSimulation = calculateCompoundInterest(0, 0, monthlyRate, maxPeriod, tax, annualInflation);
            }
            return { value: finalValue, simulation: finalSimulation };
        }
    }

    // 2. Calcular Aporte Mensal Ideal Constante - Retorna { value: number | Infinity, simulation: object | null }
    function calculateIdealMonthlyContribution(objectives, initialSavings, monthlyRate, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        let low = 0;
        const maxPeriod = Math.max(...objectives.map(o => o.period), 0);
        if (maxPeriod <= 0) return { value: 0, simulation: null };
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;
        let totalDeficit = 0;
        objectives.forEach(obj => {
            const inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, obj.period);
            const fvInitialSavings = initialSavings * Math.pow(1 + monthlyRate, obj.period);
            totalDeficit += Math.max(0, inflatedObjectiveValue - fvInitialSavings);
        });
        let high = (totalDeficit / maxPeriod) * 2 + 100;
        if (high < 100) high = 100;

        let idealContribution = Infinity;
        let finalSimulation = null;
        const maxIterations = 100;
        let iterations = 0;

        // Caso base: verificar se já atinge com 0 aporte
        const initialSimulation = calculateCompoundInterest(initialSavings, 0, monthlyRate, maxPeriod, tax, annualInflation);
        if (checkAllObjectivesMet(objectives, initialSimulation.valoresMensais, annualInflation)) {
            return { value: 0, simulation: initialSimulation }; // Nenhum aporte necessário
        }

        while (iterations < maxIterations && (high - low) > 0.01) {
            const mid = low + (high - low) / 2;
             if (mid === low || mid === high) break;

            const currentSim = calculateCompoundInterest(initialSavings, mid, monthlyRate, maxPeriod, tax, annualInflation);

            if (checkAllObjectivesMet(objectives, currentSim.valoresMensais, annualInflation)) {
                idealContribution = mid;
                finalSimulation = currentSim; // Guarda a simulação que funcionou
                high = mid;
            } else {
                low = mid;
            }
            iterations++;
        }

        if (idealContribution === Infinity) {
            // Verificar o limite superior inicial
            const highSim = calculateCompoundInterest(initialSavings, high, monthlyRate, maxPeriod, tax, annualInflation);
            if (checkAllObjectivesMet(objectives, highSim.valoresMensais, annualInflation)) {
                 // Se o high inicial funcionou, mas a busca não convergiu para ele
                 return { value: high, simulation: highSim };
            } else {
                console.warn("Não foi possível encontrar um aporte mensal suficiente dentro dos limites/iterações.");
                return { value: Infinity, simulation: null };
            }
        } else {
             const finalValue = idealContribution < 0.01 ? 0 : idealContribution;
             // Se o valor final for 0, a simulação deve ser a inicial
             if (finalValue === 0 && idealContribution >= 0.01) {
                 finalSimulation = initialSimulation;
             }
             return { value: finalValue, simulation: finalSimulation };
        }
    }

    // 3. Calcular Tempo Necessário para Atingir Objetivos - Retorna { value: number | Infinity, simulation: object | null }
    function calculateRequiredTime(objectives, initialSavings, monthlyContribution, monthlyRate, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        let totalValue = initialSavings;
        let totalInvested = initialSavings;
        let totalJuros = 0;
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;
        const maxSimulationMonths = 1200; // Limite máximo de simulação (100 anos)
        let month = 0;
        let valoresMensaisSimulacao = []; // Para guardar a simulação completa

        let objectivesMetStatus = objectives.map(obj => ({ ...obj, met: false, monthMet: -1 }));
        let allObjectivesMet = false;
        let requiredMonths = Infinity; // Começa com infinito

        // Adicionar estado inicial à simulação
        valoresMensaisSimulacao.push({
            month: 0, juros: 0, totalInvestido: initialSavings, totalJuros: 0,
            imposto: 0, valorLiquido: initialSavings, totalAcumulado: initialSavings
        });

        // Verificar se já foram atingidos no mês 0
        let numMetAtStart = 0;
        objectivesMetStatus.forEach(objStatus => {
            const inflatedObjectiveValue = objStatus.value;
            const netValueAtTargetMonth = initialSavings;
            if (objStatus.period === 0 && netValueAtTargetMonth >= inflatedObjectiveValue) {
                 objStatus.met = true;
                 objStatus.monthMet = 0;
                 numMetAtStart++;
            }
        });
        if (numMetAtStart === objectives.length) {
             // Simulação contém apenas o mês 0
             return { value: 0, simulation: { valoresMensais: valoresMensaisSimulacao } };
        }

        while (month < maxSimulationMonths) {
            month++;

            const jurosDoMes = totalValue * monthlyRate;
            totalJuros += jurosDoMes;
            totalValue += jurosDoMes + monthlyContribution;
            totalInvested += monthlyContribution;

            const impostoTotal = totalJuros * tax;
            const valorLiquido = totalValue - impostoTotal;

            // Adicionar dados do mês atual à simulação
            valoresMensaisSimulacao.push({
                month: month, juros: jurosDoMes, totalInvestido: totalInvested, totalJuros: totalJuros,
                imposto: impostoTotal, valorLiquido: valorLiquido, totalAcumulado: totalValue
            });

            let objectivesMetCount = 0;
            objectivesMetStatus.forEach(objStatus => {
                if (!objStatus.met) {
                    const inflatedObjectiveValue = objStatus.value * Math.pow(1 + monthlyInflation, month);
                    if (valorLiquido >= inflatedObjectiveValue) {
                        objStatus.met = true;
                        objStatus.monthMet = month;
                    }
                }
                if (objStatus.met) {
                    objectivesMetCount++;
                }
            });

            if (objectivesMetCount === objectives.length) {
                allObjectivesMet = true;
                requiredMonths = Math.max(...objectivesMetStatus.map(o => o.monthMet));
                break;
            }
        }

        if (requiredMonths === Infinity) {
            // Se não atingiu, retorna Infinity e a simulação até o limite máximo
            return { value: Infinity, simulation: { valoresMensais: valoresMensaisSimulacao } };
        } else {
            // Se atingiu, retorna os meses e a simulação até esse ponto
            // (A simulação já foi construída até o mês 'requiredMonths')
            return { value: requiredMonths, simulation: { valoresMensais: valoresMensaisSimulacao.slice(0, requiredMonths + 1) } };
        }
    }

    // 4. Cal    // 4. Calcular Rentabilidade Anual Ideal Constante - Retorna { value: number | Infinity, simulation: object | null }
    function calculateIdealAnnualRate(objectives, initialSavings, monthlyContribution, tax, annualInflation) {
        if (!objectives || objectives.length === 0) return { value: 0, simulation: null };

        let lowMonthlyRate = -0.05; // Permitir taxas negativas pequenas
        let highMonthlyRate = 1.0; // 100% ao mês
        let idealMonthlyRate = Infinity; // Começa com infinito
        let finalSimulation = null;
        const maxIterations = 100;
        let iterations = 0;

        const maxPeriod = Math.max(...objectives.map(o => o.period), 0);
        if (maxPeriod <= 0) return { value: 0, simulation: null }; // Sem prazo válido

        // Caso base: verificar se já atinge com taxa mínima (lowMonthlyRate)
        const lowRateSimulation = calculateCompoundInterest(initialSavings, monthlyContribution, lowMonthlyRate, maxPeriod, tax, annualInflation);
        if (checkAllObjectivesMet(objectives, lowRateSimulation.valoresMensais, annualInflation)) {
             const lowAnnualRate = Math.pow(1 + lowMonthlyRate, 12) - 1;
             // Retorna 0 se a taxa mínima for negativa mas funcionar
             return { value: Math.max(0, lowAnnualRate), simulation: lowRateSimulation };
        }

        while (iterations < maxIterations && (highMonthlyRate - lowMonthlyRate) > 1e-7) {
            const midMonthlyRate = lowMonthlyRate + (highMonthlyRate - lowMonthlyRate) / 2;
            if (midMonthlyRate === lowMonthlyRate || midMonthlyRate === highMonthlyRate) break;

            const currentSim = calculateCompoundInterest(initialSavings, monthlyContribution, midMonthlyRate, maxPeriod, tax, annualInflation);

            if (checkAllObjectivesMet(objectives, currentSim.valoresMensais, annualInflation)) {
                idealMonthlyRate = midMonthlyRate;
                finalSimulation = currentSim; // Guarda a simulação que funcionou
                highMonthlyRate = midMonthlyRate;
            } else {
                lowMonthlyRate = midMonthlyRate;
            }
            iterations++;
        }

        if (idealMonthlyRate !== Infinity) {
            const idealAnnualRate = Math.pow(1 + idealMonthlyRate, 12) - 1;
            const finalValue = idealAnnualRate < 1e-6 ? 0 : idealAnnualRate;
            // Se a taxa final for 0, a simulação correta é a de taxa 0 (que pode não ter sido a 'lowRateSimulation' inicial)
            if (finalValue === 0 && idealAnnualRate >= 1e-6) {
                 finalSimulation = calculateCompoundInterest(initialSavings, monthlyContribution, 0, maxPeriod, tax, annualInflation);
            }
            return { value: finalValue, simulation: finalSimulation };
        } else {
             // Verificar o limite superior
             const highRateSimulation = calculateCompoundInterest(initialSavings, monthlyContribution, highMonthlyRate, maxPeriod, tax, annualInflation);
             if (checkAllObjectivesMet(objectives, highRateSimulation.valoresMensais, annualInflation)) {
                 console.warn("Taxa ideal pode ser muito alta, retornando limite superior.");
                 return { value: Math.pow(1 + highMonthlyRate, 12) - 1, simulation: highRateSimulation };
             } else {
                 console.warn("Não foi possível encontrar uma taxa de rentabilidade suficiente dentro dos limites/iterações.");
                 return { value: Infinity, simulation: null }; // Indica impossibilidade
             }
        }

    // --- Função Principal de Cálculo (Modificada) ---
    function calculateSavings() {
      // Validar se há objetivos
      if (objectives.length === 0) {
        alert("Por favor, adicione pelo menos um objetivo antes de calcular.");
        return;
      }

      // Obter parâmetros financeiros comuns
      const currentSavings = parseCurrency(document.getElementById("currentSavings").value);
      const currentContribution = parseCurrency(document.getElementById("currentContribution").value);
      let rateInput = parsePercentage(document.getElementById("rate").value);
      const rateType = document.getElementById("rateType").value;
      const tax = parsePercentage(document.getElementById("tax").value);
      const annualInflation = parsePercentage(document.getElementById("inflation").value);

      // Converter taxa para mensal se for anual
      const monthlyRate = rateType === "annual" ? Math.pow(1 + rateInput, 1/12) - 1 : rateInput;

      // Determinar o período máximo de simulação baseado nos objetivos
      const maxPeriod = Math.max(...objectives.map(o => o.period), 0);
      if (maxPeriod <= 0) {
          alert("Erro ao determinar o prazo máximo dos objetivos.");
          return;
      }

      // --- Calcular Projeção Principal ---
      const projection = calculateCompoundInterest(currentSavings, currentContribution, monthlyRate, maxPeriod, tax, annualInflation);
      const valoresMensais = projection.valoresMensais;

      // --- Calcular Análises Adicionais (agora retornam { value, simulation }) --- //
      console.time("Additional Calculations");
      const analysisInitial = calculateRequiredInitialValue(objectives, monthlyRate, tax, annualInflation);
      const analysisContribution = calculateIdealMonthlyContribution(objectives, currentSavings, monthlyRate, tax, annualInflation);
      const analysisTime = calculateRequiredTime(objectives, currentSavings, currentContribution, monthlyRate, tax, annualInflation);
      const analysisRate = calculateIdealAnnualRate(objectives, currentSavings, currentContribution, tax, annualInflation);
      console.timeEnd("Additional Calculations");

      // --- Exibir Resultados --- //
      const resultDiv = document.getElementById("result");
      let resultHTML = "<h4>Resultados da Simulação Atual:</h4>";
      let allGoalsMet = true;
      let recommendationDetails = [];

      // Status dos objetivos na simulação principal
      objectives.forEach(obj => {
        const targetMonth = obj.period;
        let objectiveMet = false;
        let monthMet = -1;
        let finalNetValueForObjective = 0;
        let inflatedObjectiveValue = 0;
        const monthlyInflation = Math.pow(1 + annualInflation, 1/12) - 1;

        if (targetMonth < valoresMensais.length) {
          inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, targetMonth);
          finalNetValueForObjective = valoresMensais[targetMonth].valorLiquido;

          if (finalNetValueForObjective >= inflatedObjectiveValue) {
            objectiveMet = true;
            // Encontrar o mês exato em que foi atingido
            for(let m = 1; m <= targetMonth; m++) {
                const currentInflatedValue = obj.value * Math.pow(1 + monthlyInflation, m);
                if (valoresMensais[m].valorLiquido >= currentInflatedValue) {
                    monthMet = m;
                    break;
                }
            }
            if (monthMet === -1) monthMet = targetMonth; // Se atingiu exatamente no final
          } else {
            allGoalsMet = false;
          }

          resultHTML += `<p><strong>${obj.description}:</strong> `;
          if (objectiveMet) {
            resultHTML += `<span style="color: var(--verde-esmeralda);">Atingido!</span> (Valor líquido no mês ${targetMonth}: ${formatMoney(finalNetValueForObjective)} vs Objetivo corrigido: ${formatMoney(inflatedObjectiveValue)}). Atingido no mês ${monthMet}.</p>`;
          } else {
            resultHTML += `<span style="color: #dc3545;">Não Atingido.</span> (Valor líquido no mês ${targetMonth}: ${formatMoney(finalNetValueForObjective)} vs Objetivo corrigido: ${formatMoney(inflatedObjectiveValue)}). Faltam ${formatMoney(inflatedObjectiveValue - finalNetValueForObjective)}.</p>`;
          }
          recommendationDetails.push({ description: obj.description, met: objectiveMet, period: targetMonth, netValue: finalNetValueForObjective, targetValue: inflatedObjectiveValue });
        } else {
           resultHTML += `<p><strong>${obj.description}:</strong> Erro - Prazo do objetivo (${targetMonth} meses) excede a simulação.</p>`;
           allGoalsMet = false;
           recommendationDetails.push({ description: obj.description, met: false, period: targetMonth, netValue: 0, targetValue: obj.value });
        }
      });

      resultHTML += `<p><strong>Projeção Final (${maxPeriod} meses):</strong> Valor Líquido ${formatMoney(valoresMensais[maxPeriod].valorLiquido)} (Total Investido: ${formatMoney(valoresMensais[maxPeriod].totalInvestido)}, Juros Brutos: ${formatMoney(valoresMensais[maxPeriod].totalJuros)}, Imposto Estimado: ${formatMoney(valoresMensais[maxPeriod].imposto)})</p>`;

      // Limpar resultados das análises adicionais antes de exibir
      clearAnalysisResults();

      // Adicionar resultados das análises adicionais ao DIV principal (opcional, pois terão seções próprias)
      resultHTML += "<hr><h4>Análises Adicionais (Resumo):</h4>";
      resultHTML += `<p><strong>1. Valor Inicial Necessário (sem aportes):</strong> ${formatMoney(analysisInitial.value)}</p>`;
      resultHTML += `<p><strong>2. Aporte Mensal Ideal:</strong> ${formatMoney(analysisContribution.value)}</p>`;
      resultHTML += `<p><strong>3. Tempo Necessário:</strong> ${formatMonths(analysisTime.value)}</p>`;
      resultHTML += `<p><strong>4. Rentabilidade Anual Ideal:</strong> ${formatRate(analysisRate.value)}</p>`;
      resultHTML += `<p><i>(Veja detalhes, gráficos e memórias de cálculo de cada análise abaixo)</i></p>`;

      resultDiv.innerHTML = resultHTML;
      resultDiv.style.display = "block";

      // --- Exibir Gráficos e Tabelas das Análises Adicionais ---

      // Análise 1: Valor Inicial
      const initialValueContainer = document.getElementById("analysisInitialValueContainer");
      const resultInitialValueP = document.getElementById("resultInitialValue");
      resultInitialValueP.textContent = `Valor Inicial Necessário (sem aportes): ${formatMoney(analysisInitial.value)}`;
      if (analysisInitial.simulation && analysisInitial.simulation.valoresMensais) {
          drawInitialValueChart(analysisInitial.simulation.valoresMensais);
          fillDataTable("tableInitialValue", analysisInitial.simulation.valoresMensais);
          initialValueContainer.style.display = "block";
          showChartSlide("InitialValue", "chart");
      } else {
          initialValueContainer.style.display = "none";
      }

      // Análise 2: Aporte Ideal
      const idealContributionContainer = document.getElementById("analysisIdealContributionContainer");
      const resultIdealContributionP = document.getElementById("resultIdealContribution");
      resultIdealContributionP.textContent = `Aporte Mensal Ideal: ${formatMoney(analysisContribution.value)}`;
      if (analysisContribution.simulation && analysisContribution.simulation.valoresMensais) {
          drawIdealContributionChart(analysisContribution.simulation.valoresMensais);
          fillDataTable("tableIdealContribution", analysisContribution.simulation.valoresMensais);
          idealContributionContainer.style.display = "block";
          showChartSlide("IdealContribution", "chart");
      } else {
           idealContributionContainer.style.display = "none";
      }

      // Análise 3: Tempo Necessário
      const requiredTimeContainer = document.getElementById("analysisRequiredTimeContainer");
      const resultRequiredTimeP = document.getElementById("resultRequiredTime");
      resultRequiredTimeP.textContent = `Tempo Necessário: ${formatMonths(analysisTime.value)}`;
      if (analysisTime.simulation && analysisTime.simulation.valoresMensais) {
          // A simulação pode ser longa se o tempo for Infinity, limitar exibição?
          // Por ora, exibimos tudo.
          drawRequiredTimeChart(analysisTime.simulation.valoresMensais);
          fillDataTable("tableRequiredTime", analysisTime.simulation.valoresMensais);
          requiredTimeContainer.style.display = "block";
          showChartSlide("RequiredTime", "chart");
      } else {
          requiredTimeContainer.style.display = "none";
      }

      // Análise 4: Taxa Ideal
      const idealRateContainer = document.getElementById("analysisIdealRateContainer");
      const resultIdealRateP = document.getElementById("resultIdealRate");
      resultIdealRateP.textContent = `Rentabilidade Anual Ideal: ${formatRate(analysisRate.value)}`;
      if (analysisRate.simulation && analysisRate.simulation.valoresMensais) {
          drawIdealRateChart(analysisRate.simulation.valoresMensais);
          fillDataTable("tableIdealRate", analysisRate.simulation.valoresMensais);
          idealRateContainer.style.display = "block";
          showChartSlide("IdealRate", "chart");
      } else {
          idealRateContainer.style.display = "none";
      }

      // Gerar recomendação baseada na simulação principal
      generateRecommendation(recommendationDetails, currentContribution);

      // Desenhar gráfico e preencher tabela de projeção principal
      drawProjectionChart(valoresMensais);
      fillDataTable("tableProjection", valoresMensais);
      document.getElementById("projectionChartContainer").style.display = "block";
      showChartSlide("Projection", "chart"); // Mostrar gráfico por padrão

      // Armazenar dados do cálculo atual para salvar cenário
      currentCalculationData = {
        objectives: JSON.parse(JSON.stringify(objectives)), // Deep copy
        currentSavings,
        currentContribution,
        rate: rateType === "annual" ? rateInput : monthlyRate, // Salvar a taxa original informada
        rateType,
        tax,
        inflation: annualInflation, // Salvar inflação anual
        calculationResult: projection, // Salvar os resultados da projeção principal
        additionalAnalysis: { // Salvar resultados das análises adicionais (incluindo simulações)
            requiredInitial: analysisInitial,
            idealContribution: analysisContribution,
            requiredTime: analysisTime,
            idealAnnualRate: analysisRate
        },
        maxPeriod // Salvar o período máximo usado
      };

      // Mostrar botões de ação
      document.getElementById("saveScenarioButton").style.display = "block";
      document.getElementById("newScenarioButton").style.display = "block";
      document.getElementById("whatsappButton").style.display = "block";
      if (scenarios.length >= 1) { // Mostrar botão de análise se já houver cenários salvos
          document.getElementById("analyzeScenarioButton").style.display = "block";
      }
    }

    // --- Funções de Análise e Recomendação ---
    function generateRecommendation(objectiveResults, currentContribution) {
      const recommendationDiv = document.getElementById("recommendation");
      const recommendationText = document.getElementById("recommendationText");
      let analysis = "";
      let needsImprovement = false;

      objectiveResults.forEach(res => {
        if (!res.met) {
          needsImprovement = true;
          analysis += `<p><strong>${res.description}:</strong> O objetivo não foi atingido no prazo de ${res.period} meses na simulação atual. O valor líquido projetado é de ${formatMoney(res.netValue)}, enquanto o objetivo corrigido pela inflação seria ${formatMoney(res.targetValue)}. Seria necessário um valor adicional de ${formatMoney(res.targetValue - res.netValue)}.</p>`;
        }
      });

      if (!needsImprovement) {
        analysis += "<p><strong>Parabéns!</strong> Com os parâmetros atuais, todos os seus objetivos são atingidos dentro dos prazos definidos na simulação.</p>";
      } else {
        analysis += "<p><strong>Pontos de Atenção (Simulação Atual):</strong></p><ul>";
        if (currentContribution <= 0) {
            analysis += "<li>Iniciar aportes mensais é fundamental. Veja o 'Aporte Mensal Ideal' nos resultados acima.</li>";
        } else {
            analysis += `<li>Avalie aumentar o aporte mensal atual de ${formatMoney(currentContribution)}. Veja o 'Aporte Mensal Ideal' calculado.</li>`;
        }
        analysis += "<li>Considere buscar investimentos com maior rentabilidade (veja a 'Rentabilidade Anual Ideal' calculada, mas lembre-se que maior rentabilidade geralmente implica maior risco).</li>";
        analysis += "<li>Reavalie os prazos ou valores dos objetivos não atingidos, se possível, ou verifique o 'Tempo Necessário' calculado.</li>";
        analysis += "</ul>";
      }

      recommendationText.innerHTML = analysis;
      recommendationDiv.style.display = "block";
    }

    // --- Funções de Gráficos e Tabelas ---
    function drawGenericChart(canvasId, chartInstanceRef, valoresMensais, chartTitle) {
        const ctx = document.getElementById(canvasId).getContext("2d");
        const labels = valoresMensais.map(v => v.month);
        const bruto = valoresMensais.map(v => v.totalAcumulado);
        const liquido = valoresMensais.map(v => v.valorLiquido);
        const investido = valoresMensais.map(v => v.totalInvestido);

        // Destruir gráfico existente se houver
        if (chartInstanceRef && chartInstanceRef.chart) {
            chartInstanceRef.chart.destroy();
        }

        const newChart = new Chart(ctx, {
            type: "line",
            data: {
                labels: labels,
                datasets: [
                    {
                        label: "Valor Bruto",
                        data: bruto,
                        borderColor: "rgba(4, 108, 78, 0.8)", // Verde Esmeralda
                        backgroundColor: "transparent",
                        borderWidth: 2, pointRadius: 0, pointHoverRadius: 5, tension: 0.1
                    },
                    {
                        label: "Valor Líquido (após IR)",
                        data: liquido,
                        borderColor: "rgba(212, 175, 55, 0.8)", // Dourado
                        backgroundColor: "transparent",
                        borderWidth: 2, pointRadius: 0, pointHoverRadius: 5, tension: 0.1
                    },
                    {
                        label: "Total Investido",
                        data: investido,
                        borderColor: "rgba(111, 66, 193, 0.6)", // Roxo
                        backgroundColor: "transparent",
                        borderWidth: 2, borderDash: [5, 5], pointRadius: 0, pointHoverRadius: 5, tension: 0.1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: { callback: function(value) { return formatMoney(value); } }
                    },
                    x: { title: { display: true, text: 'Meses' } }
                },
                plugins: {
                    title: { display: false }, // Use o título do container HTML
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) { label += ': '; }
                                if (context.parsed.y !== null) { label += formatMoney(context.parsed.y); }
                                return label;
                            }
                        }
                    },
                    legend: { position: 'top' }
                }
            }
        });
        // Armazena a referência ao novo gráfico
        chartInstanceRef.chart = newChart;
    }

    // Wrapper para o gráfico de projeção principal
    function drawProjectionChart(valoresMensais) {
        drawGenericChart("chartProjection", { get chart() { return projectionChart; }, set chart(v) { projectionChart = v; } }, valoresMensais, "Evolução da Projeção Financeira");
    }

    // Wrapper para o gráfico de Valor Inicial Necessário
    function drawInitialValueChart(valoresMensais) {
        drawGenericChart("chartInitialValue", { get chart() { return initialValueChart; }, set chart(v) { initialValueChart = v; } }, valoresMensais, "Evolução - Valor Inicial Necessário");
    }

     // Wrapper para o gráfico de Aporte Mensal Ideal
    function drawIdealContributionChart(valoresMensais) {
        drawGenericChart("chartIdealContribution", { get chart() { return idealContributionChart; }, set chart(v) { idealContributionChart = v; } }, valoresMensais, "Evolução - Aporte Mensal Ideal");
    }

    // Wrapper para o gráfico de Tempo Necessário
    function drawRequiredTimeChart(valoresMensais) {
        drawGenericChart("chartRequiredTime", { get chart() { return requiredTimeChart; }, set chart(v) { requiredTimeChart = v; } }, valoresMensais, "Evolução - Tempo Necessário");
    }

    // Wrapper para o gráfico de Rentabilidade Anual Ideal
    function drawIdealRateChart(valoresMensais) {
        drawGenericChart("chartIdealRate", { get chart() { return idealRateChart; }, set chart(v) { idealRateChart = v; } }, valoresMensais, "Evolução - Rentabilidade Anual Ideal");
    }

    function fillDataTable(tableId, data) {
      const table = document.getElementById(tableId);
      const tbody = table.querySelector("tbody");
      tbody.innerHTML = ""; // Limpar tabela

      // Começar do mês 1
      for (let i = 1; i < data.length; i++) {
        const row = data[i];
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row.month}</td>
          <td>${formatMoney(row.totalInvestido)}</td>
          <td>${formatMoney(row.juros)}</td>
          <td>${formatMoney(row.totalJuros)}</td>
          <td>${formatMoney(row.totalAcumulado)}</td>
          <td>${formatMoney(row.imposto)}</td>
          <td>${formatMoney(row.valorLiquido)}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    // --- Funções de Gerenciamento de Cenários ---
    function addCurrentScenario() {
      if (!currentCalculationData) {
        alert("Nenhum cálculo foi realizado para salvar como cenário.");
        return;
      }

      const scenarioData = {
        name: `Cenário ${scenarioCounter++}`,
        ...currentCalculationData // Inclui objectives, parâmetros, resultados e análises adicionais
      };

      scenarios.push(scenarioData);
      displayScenarios();

      // Mostrar o botão de analisar cenários se houver mais de um cenário
      if (scenarios.length >= 1) {
        document.getElementById("analyzeScenarioButton").style.display = "block";
      }

      alert("Cenário salvo com sucesso!");
    }

    function displayScenarios() {
      const scenariosContainer = document.getElementById("scenariosContainer");
      const scenariosListDiv = document.getElementById("scenariosList");
      scenariosListDiv.innerHTML = ""; // Limpar lista

      if (scenarios.length === 0) {
        scenariosContainer.style.display = "none";
        return;
      }

      scenariosContainer.style.display = "block";

      scenarios.forEach((scenario, index) => {
        const card = document.createElement("div");
        card.className = "scenario-card";

        // Calcular status geral dos objetivos para este cenário
        let scenarioAllGoalsMet = false; // Assume false até verificar
        let objectivesStatusHTML = "<ul>";
        if (scenario.objectives && scenario.objectives.length > 0 && scenario.calculationResult) {
            scenarioAllGoalsMet = checkAllObjectivesMet(scenario.objectives, scenario.calculationResult.valoresMensais, scenario.inflation);
            const monthlyInflation = Math.pow(1 + scenario.inflation, 1/12) - 1;
            scenario.objectives.forEach(obj => {
                const targetMonth = obj.period;
                let objectiveMet = false;
                if (targetMonth < scenario.calculationResult.valoresMensais.length) {
                    const inflatedObjectiveValue = obj.value * Math.pow(1 + monthlyInflation, targetMonth);
                    if (scenario.calculationResult.valoresMensais[targetMonth].valorLiquido >= inflatedObjectiveValue) {
                        objectiveMet = true;
                    }
                }
                objectivesStatusHTML += `<li>${obj.description}: <span style="color: ${objectiveMet ? 'var(--verde-esmeralda)' : '#dc3545'}">${objectiveMet ? 'Atingido' : 'Não Atingido'}</span></li>`;
            });
        } else if (!scenario.objectives || scenario.objectives.length === 0) {
             objectivesStatusHTML = "<li>Nenhum objetivo definido neste cenário.</li>";
             scenarioAllGoalsMet = true; // Considera 'atingido' se não há objetivos
        } else {
            objectivesStatusHTML = "<li>Dados de cálculo indisponíveis.</li>";
        }
        objectivesStatusHTML += "</ul>";


        card.innerHTML = `
          <div class="scenario-header">
            <h4 class="scenario-title">${scenario.name}</h4>
            <div class="scenario-actions">
              <button type="button" class="scenario-select" onclick="selectScenario(${index})">Carregar</button>
              <button type="button" class="scenario-delete" onclick="deleteScenario(${index})">Excluir</button>
            </div>
          </div>
          <div class="scenario-content">
            <div class="scenario-info">
              <p><strong>Guardado:</strong> ${formatMoney(scenario.currentSavings)}</p>
              <p><strong>Aporte:</strong> ${formatMoney(scenario.currentContribution)}</p>
              <p><strong>Taxa:</strong> ${(scenario.rate * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2})}% ${scenario.rateType === 'annual' ? 'a.a.' : 'a.m.'}</p>
              <p><strong>Inflação:</strong> ${(scenario.inflation * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2})}%</p>
              <p><strong>Imposto:</strong> ${(scenario.tax * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2})}%</p>
              <p><strong>Status Geral:</strong> <span style="font-weight: bold; color: ${scenarioAllGoalsMet ? 'var(--verde-esmeralda)' : '#dc3545'}">${scenarioAllGoalsMet ? 'Objetivos Atingidos' : 'Objetivos Pendentes'}</span></p>
              <!-- Adicionar resumo das análises adicionais -->
              <p><strong>Tempo Nec.:</strong> ${formatMonths(scenario.additionalAnalysis?.requiredTime)}</p>
              <p><strong>Aporte Ideal:</strong> ${formatMoney(scenario.additionalAnalysis?.idealContribution)}</p>
              <p><strong>Taxa Ideal:</strong> ${formatRate(scenario.additionalAnalysis?.idealAnnualRate)}</p>
              <p><strong>Inicial Nec.:</strong> ${formatMoney(scenario.additionalAnalysis?.requiredInitial)}</p>
            </div>
            <div class="scenario-details">
              <strong>Objetivos:</strong>
              ${objectivesStatusHTML}
            </div>
          </div>
        `;
        scenariosListDiv.appendChild(card);
      });
    }

    function selectScenario(index) {
      if (index < 0 || index >= scenarios.length) return;
      const scenario = scenarios[index];

      // Restaurar objetivos
      objectives = JSON.parse(JSON.stringify(scenario.objectives || [])); // Deep copy
      displayObjectives();

      // Restaurar parâmetros financeiros
      document.getElementById("currentSavings").value = formatMoney(scenario.currentSavings);
      formatCurrency(document.getElementById("currentSavings"));
      document.getElementById("currentContribution").value = formatMoney(scenario.currentContribution);
      formatCurrency(document.getElementById("currentContribution"));
      document.getElementById("rate").value = (scenario.rate * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2}) + " %";
      formatPercentage(document.getElementById("rate"));
      document.getElementById("rateType").value = scenario.rateType;
      document.getElementById("tax").value = (scenario.tax * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2}) + " %";
      formatPercentage(document.getElementById("tax"));
      document.getElementById("inflation").value = (scenario.inflation * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2}) + " %";
      formatPercentage(document.getElementById("inflation"));

      // Habilitar/desabilitar campos de taxa/inflação baseado no 'knows'
      document.getElementById("knowsTax").value = scenario.tax > 0 ? "yes" : "no"; // Simplificação
      toggleTaxInput("tax", "15,00 %");
      document.getElementById("knowsInflation").value = scenario.inflation > 0 ? "yes" : "no"; // Simplificação
      toggleTaxInput("inflation", "5,00 %");

      // Limpar resultados anteriores e recalcular
      clearResults();
      calculateSavings(); // Recalcula com os dados carregados

      // Rolar para o topo do formulário
      document.getElementById("savingsForm").scrollIntoView({ behavior: 'smooth' });
      alert(`Cenário "${scenario.name}" carregado. Os resultados foram recalculados.`);
    }

    function deleteScenario(index) {
      if (index < 0 || index >= scenarios.length) return;
      const scenarioName = scenarios[index].name;
      if (confirm(`Tem certeza que deseja excluir o "${scenarioName}"?`)) {
        scenarios.splice(index, 1);
        displayScenarios();
        // Esconder botão de análise se não houver mais cenários suficientes
        if (scenarios.length < 1) { // Mudado para < 1, pois análise agora é útil com 1 cenário
          document.getElementById("analyzeScenarioButton").style.display = "none";
          document.getElementById("comparisonContainer").style.display = "none";
          document.getElementById("generalAnalysis").style.display = "none";
        } else {
            // Se ainda há cenários, mas menos de 2, esconder comparação
            document.getElementById("comparisonContainer").style.display = "none";
            document.getElementById("generalAnalysis").style.display = "none";
        }
        alert(`"${scenarioName}" excluído.`);
      }
    }

    function prepareNewScenario() {
        // Limpar objetivos
        objectives = [];
        displayObjectives();

        // Limpar campos do formulário principal
        document.getElementById("currentSavings").value = "";
        document.getElementById("currentContribution").value = "";
        document.getElementById("rate").value = "";
        // Manter taxas padrão IR/Inflação
        document.getElementById("knowsTax").value = "no";
        toggleTaxInput('tax', '15,00 %');
        document.getElementById("knowsInflation").value = "no";
        toggleTaxInput('inflation', '5,00 %');

        // Limpar resultados
        clearResults();

        // Focar no primeiro campo de objetivo
        document.getElementById("newObjectiveDescription").focus();
        alert("Campos de objetivos e resultados limpos. Pronto para um novo cálculo.");
    }

    function clearResults() {
        document.getElementById("result").style.display = "none";
        document.getElementById("result").innerHTML = "";
        document.getElementById("recommendation").style.display = "none";
        document.getElementById("recommendationText").innerHTML = "";
        document.getElementById("projectionChartContainer").style.display = "none";
        document.getElementById("whatsappButton").style.display = "none";
        document.getElementById("saveScenarioButton").style.display = "none";
        document.getElementById("newScenarioButton").style.display = "none";
        // Não esconder o botão de análise aqui, pois depende dos cenários salvos
        currentCalculationData = null;
        if (projectionChart) {
            projectionChart.destroy();
            projectionChart = null;
        }
        // Limpar também comparação se estiver visível
        if (comparisonChart) {
            comparisonChart.destroy();
            comparisonChart = null;
        }
        document.getElementById("comparisonContainer").style.display = "none";
        document.getElementById("generalAnalysis").style.display = "none";

    }

    // --- Funções de Comparação de Cenários ---
    function analyzeScenarios() {
      if (scenarios.length < 1) { // Permitir análise com 1 cenário (mostra só a tabela)
        alert("É necessário ter pelo menos 1 cenário salvo para analisar.");
        return;
      }

      if (scenarios.length >= 2) {
          updateComparisonChart();
          document.getElementById("comparisonChartContainer").style.display = "block";
          generateGeneralAnalysis();
          document.getElementById("generalAnalysis").style.display = "block";
      } else {
          // Esconder gráfico e análise geral se só tem 1 cenário
          if (comparisonChart) comparisonChart.destroy();
          document.getElementById("comparisonChartContainer").style.display = "none";
          document.getElementById("generalAnalysis").style.display = "none";
      }

      updateComparisonTable(); // Atualizar tabela sempre
      document.getElementById("comparisonContainer").style.display = "block";
      document.getElementById("comparisonContainer").scrollIntoView({ behavior: 'smooth' });
    }

    function updateComparisonChart() {
        const ctx = document.getElementById('comparisonChart').getContext('2d');
        if (scenarios.length < 2) {
             if (comparisonChart) comparisonChart.destroy();
             return; // Não desenha gráfico com menos de 2 cenários
        }

        const maxPeriodOverall = Math.max(...scenarios.map(s => s.maxPeriod), 0);
        const labels = Array.from({ length: maxPeriodOverall + 1 }, (_, i) => i);
        const datasets = [];
        const colors = [
            'rgba(4, 108, 78, 0.8)',   // Verde Esmeralda
            'rgba(212, 175, 55, 0.8)', // Dourado
            'rgba(111, 66, 193, 0.8)', // Roxo
            'rgba(220, 53, 69, 0.8)',  // Vermelho
            'rgba(0, 123, 255, 0.8)', // Azul
            'rgba(255, 193, 7, 0.8)',  // Amarelo
            'rgba(108, 117, 125, 0.8)' // Cinza
        ];

        scenarios.forEach((scenario, index) => {
            const color = colors[index % colors.length];
            const data = new Array(maxPeriodOverall + 1).fill(null);
            if (scenario.calculationResult && scenario.calculationResult.valoresMensais) {
                scenario.calculationResult.valoresMensais.forEach((val, month) => {
                    if (month <= maxPeriodOverall) {
                        data[month] = val.valorLiquido;
                    }
                });
                // Preencher valores futuros com o último valor calculado se a simulação for mais curta
                const lastValue = data[scenario.maxPeriod];
                for (let m = scenario.maxPeriod + 1; m <= maxPeriodOverall; m++) {
                    data[m] = lastValue;
                }
            }

            datasets.push({
                label: scenario.name,
                data: data,
                borderColor: color,
                backgroundColor: 'transparent',
                borderWidth: 2,
                pointRadius: 0,
                pointHoverRadius: 4,
                tension: 0.1
            });
        });

        if (comparisonChart) {
            comparisonChart.destroy();
        }

        comparisonChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) { return formatMoney(value); }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Meses'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) { label += ': '; }
                                if (context.parsed.y !== null) {
                                    label += formatMoney(context.parsed.y);
                                }
                                return label;
                            }
                        }
                    },
                    legend: {
                        position: 'top',
                    }
                }
            }
        });
    }

    function updateComparisonTable() {
        const table = document.getElementById('comparisonTable');
        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');
        thead.innerHTML = '';
        tbody.innerHTML = '';

        if (scenarios.length === 0) return;

        // Cabeçalho
        let headerRow = '<tr><th>Métrica</th>';
        scenarios.forEach(s => headerRow += `<th>${s.name}</th>`);
        headerRow += '</tr>';
        thead.innerHTML = headerRow;

        // Linhas de Dados
        const metrics = [
            { key: 'currentSavings', label: 'Valor Guardado', format: formatMoney },
            { key: 'currentContribution', label: 'Aporte Mensal', format: formatMoney },
            { key: 'rate', label: 'Taxa Juros', format: (v, s) => `${(v * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2})}% ${s.rateType === 'annual' ? 'a.a.' : 'a.m.'}` },
            { key: 'inflation', label: 'Inflação Anual', format: v => `${(v * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2})}%` },
            { key: 'tax', label: 'Imposto (IR)', format: v => `${(v * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2})}%` },
            { key: 'finalNetValue', label: 'Valor Líquido Final', format: formatMoney, calc: s => s.calculationResult?.valoresMensais[s.maxPeriod]?.valorLiquido },
            { key: 'totalInvested', label: 'Total Investido Final', format: formatMoney, calc: s => s.calculationResult?.valoresMensais[s.maxPeriod]?.totalInvestido },
            { key: 'totalInterest', label: 'Juros Brutos Finais', format: formatMoney, calc: s => s.calculationResult?.valoresMensais[s.maxPeriod]?.totalJuros },
            { key: 'goalsMetStatus', label: 'Status Objetivos', format: (v, s) => {
                if (!s.objectives || s.objectives.length === 0) return 'N/A';
                const allMet = checkAllObjectivesMet(s.objectives, s.calculationResult?.valoresMensais, s.inflation);
                return allMet ? '<span style="color: var(--verde-esmeralda);">Todos Atingidos</span>' : '<span style="color: #dc3545;">Pendentes</span>';
            } },
            // Métricas Adicionais
            { key: 'requiredInitial', label: 'Inicial Necessário', format: formatMoney, calc: s => s.additionalAnalysis?.requiredInitial },
            { key: 'idealContribution', label: 'Aporte Ideal', format: formatMoney, calc: s => s.additionalAnalysis?.idealContribution },
            { key: 'requiredTime', label: 'Tempo Necessário', format: formatMonths, calc: s => s.additionalAnalysis?.requiredTime },
            { key: 'idealAnnualRate', label: 'Taxa Ideal Anual', format: formatRate, calc: s => s.additionalAnalysis?.idealAnnualRate }
        ];

        metrics.forEach(metric => {
            let row = `<tr><td>${metric.label}</td>`;
            const values = scenarios.map(s => metric.calc ? metric.calc(s) : s[metric.key]);

            // Para métricas numéricas, encontrar melhor/pior
            let bestValue = null, worstValue = null;
            let numericValues = values.map(v => typeof v === 'number' && isFinite(v) ? v : null).filter(v => v !== null);
            let isNumeric = numericValues.length > 0;

            if (isNumeric && numericValues.length > 1) {
                 // Definir se maximiza ou minimiza
                 const maximize = ['finalNetValue', 'totalInterest'].includes(metric.key);
                 const minimize = ['tax', 'inflation', 'requiredInitial', 'idealContribution', 'requiredTime', 'idealAnnualRate'].includes(metric.key);

                 if (maximize) {
                    bestValue = Math.max(...numericValues);
                    worstValue = Math.min(...numericValues);
                 } else if (minimize) {
                    bestValue = Math.min(...numericValues);
                    worstValue = Math.max(...numericValues);
                 }
            }

            scenarios.forEach((s, index) => {
                const value = values[index];
                let formattedValue = metric.format(value, s);
                let className = '';
                if (isNumeric && bestValue !== null && typeof value === 'number' && isFinite(value)) {
                    if (value === bestValue) className = 'best-value';
                    else if (value === worstValue) className = 'worst-value';
                }
                // Adiciona classe para N/A ou Inatingível para estilização se necessário
                if (formattedValue === 'N/A' || formattedValue === 'Inatingível') {
                    className += ' value-na';
                }
                row += `<td class="${className}">${formattedValue}</td>`;
            });
            row += '</tr>';
            tbody.innerHTML += row;
        });
    }

    function generateGeneralAnalysis() {
        const analysisDiv = document.getElementById('generalAnalysisText');
        analysisDiv.innerHTML = ""; // Limpar análise anterior

        if (scenarios.length < 2) {
            analysisDiv.innerHTML = "<p>Adicione pelo menos dois cenários para gerar uma análise comparativa detalhada.</p>";
            return;
        }

        let text = "<p>Comparando os cenários:</p><ul>";

        // Função auxiliar para encontrar melhor cenário para uma métrica
        const findBestScenario = (metricKey, maximize = true) => {
            let bestValue = maximize ? -Infinity : Infinity;
            let bestScenario = null;
            scenarios.forEach(s => {
                const value = s.additionalAnalysis ? s.additionalAnalysis[metricKey] : (s.calculationResult ? s.calculationResult.valoresMensais[s.maxPeriod][metricKey === 'finalNetValue' ? 'valorLiquido' : metricKey] : null);
                 if (typeof value === 'number' && isFinite(value)) {
                    if ((maximize && value > bestValue) || (!maximize && value < bestValue)) {
                        bestValue = value;
                        bestScenario = s;
                    }
                 }
            });
            return { scenario: bestScenario, value: bestValue };
        };

        // Comparar Valor Líquido Final
        const bestFinal = findBestScenario('finalNetValue', true);
        if (bestFinal.scenario) {
            text += `<li>O <strong>${bestFinal.scenario.name}</strong> apresenta o maior valor líquido final projetado (${formatMoney(bestFinal.value)}).</li>`;
        }

        // Comparar Tempo Necessário
        const bestTime = findBestScenario('requiredTime', false);
        if (bestTime.scenario && isFinite(bestTime.value)) {
             text += `<li>O <strong>${bestTime.scenario.name}</strong> atinge todos os objetivos no menor tempo (${formatMonths(bestTime.value)}).</li>`;
        } else if (scenarios.some(s => s.additionalAnalysis?.requiredTime === Infinity)) {
             text += `<li>Alguns cenários podem não atingir todos os objetivos (tempo infinito).</li>`;
        }

        // Comparar Aporte Ideal
        const bestContribution = findBestScenario('idealContribution', false);
        if (bestContribution.scenario && isFinite(bestContribution.value)) {
            text += `<li>O <strong>${bestContribution.scenario.name}</strong> requer o menor aporte mensal ideal (${formatMoney(bestContribution.value)}) para atingir os objetivos com os parâmetros dados.</li>`;
        }

         // Comparar Taxa Ideal
        const bestRate = findBestScenario('idealAnnualRate', false);
        if (bestRate.scenario && isFinite(bestRate.value)) {
            text += `<li>O <strong>${bestRate.scenario.name}</strong> requer a menor rentabilidade anual ideal (${formatRate(bestRate.value)}) para atingir os objetivos com os parâmetros dados.</li>`;
        }

        // Comparar Valor Inicial Necessário
        const bestInitial = findBestScenario('requiredInitial', false);
        if (bestInitial.scenario && isFinite(bestInitial.value)) {
            text += `<li>O <strong>${bestInitial.scenario.name}</strong> requer o menor valor inicial (${formatMoney(bestInitial.value)}) para atingir os objetivos sem aportes, com a taxa dada.</li>`;
        }

        text += "</ul><p>Analise a tabela e o gráfico acima para mais detalhes sobre as diferenças entre os parâmetros e resultados de cada cenário.</p>";
        analysisDiv.innerHTML = text;
    }


    // --- Função de Integração WhatsApp ---
    async function openWhatsAppChat() {
      let objectivesText = "Objetivos:\n";
      if (objectives.length > 0) {
        objectives.forEach(obj => {
          objectivesText += `- ${obj.description}: ${formatMoney(obj.value)} em ${obj.period} meses\n`;
        });
      } else {
        objectivesText = "Nenhum objetivo definido.\n";
      }

      let parametersText = "Parâmetros Financeiros:\n";
      let analysisText = "Análises Adicionais:\n";
      if (currentCalculationData) {
         parametersText += `  - Valor Guardado: ${formatMoney(currentCalculationData.currentSavings)}\n`;
         parametersText += `  - Aporte Mensal: ${formatMoney(currentCalculationData.currentContribution)}\n`;
         parametersText += `  - Taxa Juros: ${(currentCalculationData.rate * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2})}% ${currentCalculationData.rateType === "annual" ? "a.a." : "a.m."}\n`;
         parametersText += `  - Inflação: ${(currentCalculationData.inflation * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2})}%\n`;
         parametersText += `  - Imposto: ${(currentCalculationData.tax * 100).toLocaleString("pt-BR", {minimumFractionDigits: 2, maximumFractionDigits: 2})}%\n`;

         analysisText += `  - Inicial Necessário (s/ aporte): ${formatMoney(currentCalculationData.additionalAnalysis?.requiredInitial)}\n`;
         analysisText += `  - Aporte Ideal: ${formatMoney(currentCalculationData.additionalAnalysis?.idealContribution)}\n`;
         analysisText += `  - Tempo Necessário: ${formatMonths(currentCalculationData.additionalAnalysis?.requiredTime)}\n`;
         analysisText += `  - Taxa Ideal Anual: ${formatRate(currentCalculationData.additionalAnalysis?.idealAnnualRate)}\n`;

      } else {
          parametersText = "Parâmetros financeiros não calculados.\n";
          analysisText = "Análises adicionais não calculadas.\n";
      }

      // Tenta pegar a descrição geral do primeiro objetivo como contexto
      const goalContext = objectives.length > 0 ? objectives[0].description : "(Objetivo não descrito)";

      const message = `Oi Hugo, queria tua ajuda com meus objetivos:\n${goalContext}\n\n${objectivesText}\n${parametersText}\n${analysisText}\nEstou usando a calculadora que você criou.`;
      const encodedMessage = encodeURIComponent(message);
      const whatsappUrl = `https://api.whatsapp.com/send?phone=5581994297920&text=${encodedMessage}`;
      window.open(whatsappUrl, "_blank");
    }

    // --- Inicialização ---
    document.addEventListener('DOMContentLoaded', (event) => {
        // Inicializar exibição de objetivos (vazia no início)
        displayObjectives();
        // Configurar valores padrão para IR e Inflação
        toggleTaxInput('tax', '15,00 %');
        toggleTaxInput('inflation', '5,00 %');
    });

  </script>
</body>
</html>

